Spring Boot is a new model to develop spring applications.

Features
-----------
1) Flexibility over configuration - Annotation, java config classes or zero configurations.

2) Starters dependency - (Combination of required jars)
	- A group of related dependencies with appropriate versions.

3) Embedded server - (Tomcat, Jetty etc.)

4) Profiles (To make application compatible for different environments - just need to activate the related profile at the time of development)

5) Actuators - Inside details of application during runtime like heap size, memory information, server status etc.


SpringBoot Core/ AOP
SpringBoot MVC
SpringBoot Data JPA
SpringBoot Data MongoDB
SpringBoot Security
SpringBoot Restful Web services
SpringBoot Data Redis
SpringBoot Security Oath2
SpringBoot Profiles
SpringBoot Atuator
SpringBoot Batch
SpringBoot Kafka

Monolithic application - Single jar/ war for whole application
------------------------------------------------------------------
- It has the following drawbacks

	1) Large App 
		- Increase development time, may cause downtime during deployment even though changes are very small.
		- Large deployment & startup time
	2) Scaling
		- Difficult to handle when large traffic for a single module, entire application goes down.

	3) One Technology Stack -Entire development is done only with one technology, Other language/ technology support not available.

Solution of Monolithic approach is - Micro-services.

Micro-services
------------------
- Split of large system into smalls.
- Independent responsibility for each micro services.
- Scaling [If one micro-service is having downtime/ load - only that particular micro-service can be scaled up without interrupting others.]
- Multi language development possible (Interoerability). 


pom.xml
===============
1) Add <parent> tag - above dependency tag
	
	<parent> 
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.3.1.RELEASE</version>
	</parent>

2) Add dependencies
	
	<dependency>	
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter</artifactId>

		/* Here version is automatically inherited from parent, so no need to provide */ 

	</dependency>

3) Add plugin

	- Spring boot provided plugins to maven to build, run, test & package for war/jar with goal etc...

	<plugin>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-maven-plugin</artifactId> /* To build & execute spring boot app */
	</plugin>


- In order to migrate existing application, add these three tags in pom.xml
- To create new spring boot project, needs spring initializer tool which adds all the stuffs in pom.xml like start.spring.io
- Every spring boot application have entry point class with main method and application executes from this main method only.
- The entry point class must have annotated with @SpringBootApplication. 
- @SpringBootApplication consist of three annotations :
	[@Configuration / @SpringBootConfiguration + @ComponentScan + @EnableSpringBootConfiguration].


@SpringBootApplication
---------------------------------
	- class level annotation
	- entry point of spring boot application
	- combination of :
		- @SpringBootConfiguration (or SpringConfiguration - both are same)
		- @EnableAutoConfiguration (Automatically configures jars which are available in class path)
		- @ComponentScan
	- The class annotated with @SpringBootApplication, acts also as a configuration class and the class can contain bean configurations methods.
	- Spring boot application runs as a SpringApplication.

spring-boot-configuration module - contains auto configuration classes
	for e.g. 
	-----------
	spring-boot-starter-web - spring-boot-configuration module configures all the jars associated this starter dependency automatically.


@SpringBootApplication
public class DemoApp {
	public static void main(String args[]){
		
		SpringApplication.run(DemoApp.class, args);
		
		// BOOTSTRAPPING
		//-------------------
		//run is a static method and does the following internally :
		//1) creates ApplicationContext (A type of container which manages entire beans) - loads all the beans of the application to the 						ApplicationContext with the help of DemoApp.class.
		//2) registers CommandLinePropertySource bean (This class Converts command line arguments to spring application properties)
		//3) refreshes ApplicationContext with singleton beans
		//4) triggers CommandLineRunner bean classes

		//- Just before ready to run spring boot application, CommandLineRunner executes(If you want to execute any logic one time just before spring boot application is going to start. for e.g. - like load all the job schedules from database or to insert users with encrypted password for admin users to database.)
		- CommandLineRunner is an interface provides a method run().
		- We can define multiple CommandLineRunner by implementing in our classes, but needs provide order of execution else will run randomly.

		// These all for steps are called bootstrapping(initialising the application).
		
	}
}

CommandLineRunner implementation (by custom)
---------------------------------------------
@Component 
@Order(2) // Defines execution order for the class - low the number higher the priority
public class LoadSchedulesRunner implements CommandLineRunner {
	@Override
	public void run(String... args) {
		//logic
	}
}

@Component 
@Order(1)
public class DataRunner implements CommandLineRunner {
	@Override
	public void run(String... args) {
		//logic
	}
}

$mvn spring-boot:run //Maven uses Spring boot maven plugin to compile & run

$java -jar filename.jar

Deploy Docker image in cloud

CommandLinePropertySource
----------------------------
 - If any value passed by command line argument, it reads those & add to the 'Environment Object' of the application.
 
 - It is similar to write properties in application.properties/ application.yml

  
 

9505360660 - mohd. Basith. - Sathya Tech - 5000 - google pay
send screenshot of payment to 9100920092 whatsapp.

paid

-----------------------------------------------------------------


Spring Boot - Summary
-----------------------
# Why boot?
	- Zero/Less configuration
		* Earlier Spring has provided flexibility to define configurations in multiple ways like xml, annotations, java configuration classes.
	- Starter dependency
		* Boot provided combination of compatible dependency in a single starter dependency
	- Embeded server
		* Earlier had to deploy jar/war to server manually.
	- When application moves on from one environment to another then you had to change application properties manually.   
	
- Spring Boot is a new model to create spring applications, but it is not a new framework

- Features
	* Zero or Minimal configurations
	* Starter Dependencies
	* Embedded servers
	* Opinionated view - Default configuration with customisations 
	* profiles
	* actuators - Production ready features

- Requirements for Spring Boot		
	1) Java 8+
	2) Maven/ Gradle

- Changes to pom.xml
	1) Add parent tag
	2) Add starter dependencies
	3) add plugin
	
- If you want to migrate a spring application to spring boot application, you need to add the changes to pom.xml manually.

- A new spring boot applications are generated through spring initialiser tool, which automatically adds the required changes in pom.xml.


@SpringBootApplication
-------------------------
* Every spring boot application executes from java main(). 
* To make a class as an entry point for spring boot project, add @SpringBootApplication on class 
* @SpringBootApplication = @SpringBootConfiguration + @EnableAutoConfiguration + @ComponentScan
* Every spring boot application class is a configuration class, in which you can define bean methods to customize the configurations.
* In spring boot, we have auto configure module with a group of auto configuration classes which automatically adds the required bean configurations based on the jars available on classpath.

com.pack // base package - contains main method - does auto configure from its package.  
com.pack.service
com.pack.controller
com.pack.entity
com.pack.model
com.pack.dao
com.pack.utilities

* Bydefault, components auto scan starts from spring boot application's base package to its sub packages.
It can be customized with scanBasePackages element.
(If configuration available in package other than base package path) 

@SpringBootApplication(scanBasePackages={"package1", "package2", ...})

SpringApplication.run()
----------------------------
* Spring boot has provided SpringApplication class, to run a spring boot application as a spring based application from java main method.
* The run() has two parameters : 
	1) Spring Boot Application class Class object
	2) command-line arguments

for e.g.
----------
@SpringBootApplication
public class DemoApplication {
	psvm(String args[]) {
		SpringApplication.run(DemoApplication.class, args);
	}
}

Stereo type annotations - defines role of the class
----------------------------------------------------------
@Component - spring bean class
@Service
@Controller
@RestController
@Repository 
@Configuration - java configuration class

CommandLineRunner
---------------------
- Triggers just before running spring boot application.
- Multiple CommandLineRunner can be defined with run order.

STS(Spring Tools Suite) IDE - File - new Spring Starter Project 
Name - Demo1 | Type - Maven | Packaging - jar | Java Version - 8
Group(Organisation) - com.sathyatech
Artifact(Project Name) - Demo1
Version 1.1
package(Base package) - com.demo

Next - Spring Boot Version - 2.3.3 | Dependencies - ...if any like web, lombok etc. (If not add any dependency, it will be added Spring-Boot-Starter dependency only).

pom.xml - plugin(spring-boot-maven-plugib) - spring provided this plugin to build & run spring boot application.

Demo1Application.java - this class is created automatically according to the Project name.

@SpringBootApplication
public class Demo1Application {
	psvm(String args[]) {
		SpringApplication.run(Demo1Application.class, args);
	}
}

package com.demo.bean;
@Component
public class HelloWorldBean {
	public String sayHello() {
		return "Hello World";
	}
}

package com.demo.runner;
@Component
public class MyRunner implements CommandLineRunner{
	@Autowired //Object/collection dependencies - if bean is conflicting then use @Qualifier
	HelloWorldBean helloWorld;

	@Override
	public void run(String... args) throws Exception{
		System.out.println(helloWorld.sayHello());
	}
}

Go to main() class & run as java application.
or
manven - maven build ... - command = build
project - target - Demo1-1.1.jar
$ [go to project path]
$ java -jar target/Demo1-1.1.jar
or 
$ mvn spring-boot:run

If mvn is showing error like - not a command
- download maven, extract & set maven on environmental path
- apache-maven-3.5.2\bin : add this to path variable.
 
$ mvn --version
$ mvn clean package [clean - to clean previous build, package - packaging jar]
$ mvn spring-boot:run - to run boot project inside the project directory

Application properties is set by either of :
1) application.properties
2) application.yaml
3) command line argument
4) CommandLineRunner class

command line argument has two types
1) Optional arguments [contains key=value, starts with '--']
	for e.g.
	---------
	$ java -jar target/filename.jar --key=value

2) Non-optional arguments [contains only value]

	for e.g. 
	------------
	$ java -jar target/filename.jar --key=value --key=value nonoptional1 nonoption2


ApplicationRunner interface
--------------------------------
- like CommandLineRunner interface & it has also a run() but it takes ApplicationArguments

- run(ApplicationArguments args)

- ApplicationArguments separates Optional & non-optional command line arguments.

- If you want to set properties at the time of runtime then go for ApplicationRunner.

with @Values can be injected values to the bean - It is called value injection.


@Component
public class HelloWorldBean {
	//@Value("Hello World")
	@Value(${msg.key})
	String message;

	public String sayHello() {
		return message;
	}
}

application.properties
--------------------------
msg.key=Hello World!


- If we provide value at runtime with argument, it will override application properties value.
$ java -jar target/Demo-1.1.jar --msg.key="It's a boot application" [This message will be shown].

So, command line argument has high priority.

If properties file name is not "application.properties" then use @PropertySource(classpath:myfile.properties) in @SpringBootApplication class

create a spring core app : 
-----------------------------
package com.demo
@SpringBootApplication
public class Demo2Application {
	psvm(String args[]) {
		SpringApplication.run(Demo2Application.class, args);
	}
}

package com.demo.runner;
@Component
public class MyApplicationRunner implements ApplicationRunner {
	@Override
	public void run(ApplicationArguments args) throw Exception {
		//ApplicationArguments has separate methods for option & nonoption arguments 

		//To print all Non-option args
		List<String> nonOptionArgsList = args.getNonOptionArgs();
		sysout("Non-option args from command line : ");
		nonOptionArgsList.forEach(System.out::println);

		sysout("=====================");

		//To print all option args
		//One key can have multiple values.
		Set<String> optionArgsNames = args.getOptionNames();
		optionArgsNames.forEach((name)-> {
			List<String> optionArgValues = args.getOptionValues(name);
			System.out.print(name + " : "); //name
			optionArgValues.forEach(System.out::print+" "); //associated values
		}); 
	}
}

$ mvn spring-boot:run -Dspring-boot.run.arguments="--id=101 --name=Stahya,Shekher Amirpet Hyderabad"
or
$ java -jar target/Demo2-1.1.jar --id=101 --name=Stahya,Shekher Amirpet Hyderabad

$ java -jar target/Demo2-1.1.jar --id=101 --name=Stahya,Shekher Amirpet Hyderabad --id=10001

Note : id=10001 does not override id=101. It will keep both with coma sepearted


To Autowire Option & Non-Option args in a class
----------------------------------------------------

@Component
public class Warehouse {
	List<String> warehouseTypes;

	@Autowired
	ApplicationArguments args;

	public void addWarehouseTypes(){
		List<String> list = args.getNonOptionArgs();
		list.forEach(value->warehouse.add(value));
	}
}

Command Line Arguments
------------------------------
CommandLineRunner - run(String... args)
ApplicationRunner - run(ApplicationArguments args)

Command line arguments
1) option args [--key=value]
2) non-option args [value]

- application.properties - define arguments here at development time.

- Command Line Arguments override application.properties values.

For e.g with DI
------------------------
package com.demo.bean;
@Component
public class PolicyBean{

	@Value("${policy.company}")
	String policyCompany;
	
	List<String> policyTypes = new ArrayList<String>();

	@Autowired
	ApplicationArguments args;

	public void showDetails() {
		List<String> nonOptionArgs = args.getNonOptionArgs();
		nonOptionArgs.forEach((name)->{
			policyTypes.add(name);
		});
		
		sysout("Policy company: "+policyCompany);
		sysout("Policy Type: ");
		policyTypes.forEach(System.out::println);
	}
	
}

package com.demo.runner;

@Component
public class MyRunner implements CommandLineRunner {
	@Autowired
	PolicyBean policyBean;

	@Override
	public void run(String... args) throws Exception {
		policyBean.showDetails();
	}
}

application.pproperties
------------------------
policy.company=LIC

- package it 

$ java -jar target/Demo3-1.1.jar --policy.company="LIC Of India" "Endowment Plan" "Term Insurance Plan" "Money Back Plan"

- We can make the main class of spring boot app also a CommandLineRunner like this - because @SpringBootApplication is also a @Component : 
@SpringBootApplication 
public class Demo3Application implements CommandLineRunner {
	@Autowired
	PolicyBean policyBean;

	public static void main(String args[]){
		SpringApplication.run(Demo3Application.class, args);
	}

	@Override
	public void run(String... args) throws Exception {
		policyBean.showDetails();
	}
}


CommandLineRunner
---------------------
	- Implement this interface into a class to define a code to run before a spring boot application's bootstrapping is going to finish.
	- Just before a spring boot application becomes ready to use by the users, the command line runner beans of application will be executed.
	- You can define multiple CommandLineRunner and define the order of their executions with @Order.

ApplicationRunner
-------------------
	- It is also like CommandLineRunner only, but it provides a run() with ApplicationArguments parameters to access option and non-option arguments separately.
	- An option argument has a key-value. [--key=value]
	- An option argument has a value only. [without --]

	$ java -jar target/appname.jar --key=value --server.port=2020 --db.user=system IamNonOption1 "I am Non Option2"
	
	$ mvn spring-boot:run -Dspring-boot.run.arguments="--key=value --server.port=2020 --db.user=system IamNonOption1 'I am Non Option2'"


Spring-JDBC [spring-boot-starter-jdbc & DB Driver dependencies]
=================================================================== 
	- Checked exception
	- No boiler plate code
	- Provides an abstraction layer over JDBC - JdbcTemplate class
		- JdbcTemplate class depends on DataSource[interface].
			DataSource[interface] implementation :
				- DriverManagerDataSource class
				- HikariDataSource class

 
	
spring-jdbc project
------------------------
	pom.xml
	--------------------------
	- spring-boot-starter-jdbc(JDBC API) & Oracle Driver(ojdbc8) dependencies
	
	application.properties
	--------------------------
	spring.datasource.driver-class-name=oracle.jdbc.driver.OracleDriver
	spring.datasource.url=jdbc:oracle:thin:@localhost:1521:xs
	spring.datasource.username=system
	spring.datasource.password=tiger

	package com.demo.dao;
	public interface EmpDaoIntf {
		void updateEmp(double salary, int deptno);
		Map findEmpById(int empno);
		List<Map<String, Object>> findAll();
	}

	package com.demo.dao.impl;
	@Repository
	public class EmpDaoImpl implements EmpDaoIntf {

		@Autowired 
		JdbcTemplate jdbcTemplate;

		@Override
		void updateEmp(double salary, int deptno){
			jdbcTemplate.update("UPDATE EMP SET SAL=? WHERE DEPTNO=?", salary, deptno);
		}

		@Override
		Map findEmpById(int empno) {
			return jdbcTemplate.queryForMap("SELECT * FROM EMP WHERE EMPNO=?",empno); //Single record selection
		}

		@Override
		List<Map<String, Object>> findAll() {
			return jdbcTemplate.queryForList("SELECT * FROM EMP"); //Multi row records
		}
	}

	package com.demo.runner;
	@Component		
	public class MyRunner implements CommandLineRunner {
		@Autowired
		EmpDaoIntf intf;

		@Override
		public void run(String... args) throws Exception {
			intf.updateEmp(5999.0, 20);
			
			sysout(intf.findEmpById(7788));

			List<Map<String, Object>> list = intf.findAll();
			list.forEach(System.out::println); 
		}
	}
	
	run app 

Spring Boot MVC
==================
- Web applications can be created using Servlet & JSP technologies which provides tightly coupled solution.
- Model(data/business), view(presentation), controller(navigates between model & view).
- Front Controller (DispatcherServlet) - Controls each & every request

- In java MVC & MVC2 architectures are there.
	- In MVC(No Helper class), front controller contacts with appropriate Model directly then controller decides appropriate view.
	- In MVC2(Use Helper class), front controller servlet use Helper classes to identify Model & View classes. 
	- Spring MVC follows MVC2 architecture where need to configure servlet_name-servlet.xml and also need to add DispatcherServlet to web.xml 
		WEB-INF/ web.xml & <servlet_name-servlet.xml> files
		web.xml
		--------------
		<web-app>
			<servlet>
				<servlet-name>spring</servlet-name>
				<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
				<load-on-startup>1</load-on-startup> //for early load of servlet.
			</servlet>
			<servlet-mapping>
				<servlet-name>spring</servlet-name>
				<url-pattern>/</url-pattern>
			</servlet-mapping>
		</web-app>
	- Spring boot MVC - No need to configure web.xml or view response 

	spring MVC
	-----------
		Controller
		---------------
		@Controller - class level annotaion
		@RequestMapping/ @GetMapping/ @PutMapping/ @PostMapping/ @DeleteMapping - Method level annotations 
	

		@Controller
		public class UserController { //Controller Bean class

			//Old style
			@RequestMapping(value="/getUsers", method = RequestMethod.GET)
			public ModelAndView findUsers() {
				---
				---
			}

			//New Style
			@GetMapping("/getUsers")
			public ModelAndView findUsers() {// findUsers() is called Handler Method
				---
				---

				return new ModelAndView("view_name", "model_name", model_value); //String, String, Object -- will return view_name.jsp
				//InternalResourceViewResolver - to resolve a view name to actual view by adding a prefix & suffix - which needs to configure.
 
			}

		}
 

		1) DispatcherServlet calls HandllerMapping[RequestMappingHandlerMapping] bean to identify appropriate Controler
		2) HandllerMapping[RequestMappingHandlerMapping] bean returns appropriate Controller which associates the request to DispatcherServlet.
		3) Then DispatcherServlet calls that Controller bean.



	@Controller
	public class EmployeeController {
		@GetMapping("/index")
		public ModelAndView getIndexPage() {
			return new ModelAndView("index");
		}
	}
	
	@GetMapping("/employee/deptno") 
	public ModelAndView getEmployeesByDeptno(int deptno) {
		List<Employee> wmpList = service.findEmpsByDno(deptno);
		return new ModelAndView("show", "employee", empList);
	}


	- In SpringBoot by default InternalResourceViewResolver class is associated for View Resolver bean. It maps the view name to actual view.
	- InternalResourceViewResolver maps actual view by appending prefix & suffix.
		prefix = "/WEB-INF/views/"
		suffix = ".jsp"

		So, "/WEB-INF/views/show.jsp" will be the response for the DispatcherServelt, then DispatcherServelt renders show.jsp & responds.
	
		/WEB-INF/views/*.jsp

	- In SpringBoot prefix & suffix to be set in application.properties

	- Web applications are created to share resources. these resources may be a page/data/functionality.


	Current development scenario - No need to return ModelAndView object, just need to set model data to ModelMap & return view name 
	----------------------------------------------------------------------------------------------------------------------------------
	@GetMapping("/employees")
	public String getEmployees(ModelMap model) { //ModelMap is a type of Map only, instead of ModelMap it can be used Model/ Map**
		List<Employee> employeesList = service.findEmployees();
		model.addAttribute("employees", employeesList); //Model is set to ModelMap
		return "show"; //Returns only view name
	}
	
	**ModelMap extends LinkedHashMap implements Model [Model is from spring]

	Simple Spring MVC(No Spring boot) application development requires :
	------------------------------------------------------------------------
	1) MVC related dependencies to pom.xml
	2) add DispatcherServlet configuration to web.xml
	3) define spring configuration in dispatcher-servlet.xml
	4) deploy war on a server


	Spring boot MVC application development requires :
	-------------------------------------------------------
	1) add spring-boot-starter-web in pom.xml
	2) add server/ prefix/ suffix properties in application.properties
	3) run application

	Create application - starts.spring.io
	-------------------------------------------
	dependencies - 
	----------------
	1) spring-boot-starter-web
	2) //If jsp is a view
		<groupId>org.apache.tomcat.embed</groupId>
		<artifactId>tomcat-embed-jasper</artifactId>

	application.properties
	----------------------------
	server.port=2223
	server.servlet.context-path=/mvc
	spring.mvc.view.prefix=/WEB-INF/views/
	spring.mvc.view.suffix=.jsp

	
	package com.mvc.controller;
	@Controller
	public class HelloController {
		@GetMapping("/hello")
		public String returnWelcomePage() {
			return "welcome";
		}
	}

	create a jsp file in this directory :
	/src/main/webapp/WEB-INF/views/welcome.jsp
			
	welcome.jsp
	---------------
	<h1>Jai Ram G ki</h1>

	
	run & request as http://localhost:2223/mvc/hello



	
	











