Spring Boot is a new model to develop spring applications.

Features
-----------
1) Flexibility over configuration - Annotation, java config classes or zero configurations.

2) Starters dependency - (Combination of required jars)
	- A group of related dependencies with appropriate versions.

3) Embedded server - (Tomcat, Jetty etc.)

4) Profiles (To make application compatible for different environments - just need to activate the related profile at the time of development)

5) Actuators - Inside details of application during runtime like heap size, memory information, server status etc.


SpringBoot Core/ AOP
SpringBoot MVC
SpringBoot Data JPA
SpringBoot Data MongoDB
SpringBoot Security
SpringBoot Restful Web services
SpringBoot Data Redis
SpringBoot Security Oath2
SpringBoot Profiles
SpringBoot Atuator
SpringBoot Batch
SpringBoot Kafka

Monolithic application - Single jar/ war for whole application
------------------------------------------------------------------
- It has the following drawbacks

	1) Large App 
		- Increase development time, may cause downtime during deployment even though changes are very small.
		- Large deployment & startup time
	2) Scaling
		- Difficult to handle when large traffic for a single module, entire application goes down.

	3) One Technology Stack -Entire development is done only with one technology, Other language/ technology support not available.

Solution of Monolithic approach is - Micro-services.

Micro-services
------------------
- Split of large system into smalls.
- Independent responsibility for each micro services.
- Scaling [If one micro-service is having downtime/ load - only that particular micro-service can be scaled up without interrupting others.]
- Multi language development possible (Interoerability). 


pom.xml
===============
1) Add <parent> tag - above dependency tag
	
	<parent> 
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.3.1.RELEASE</version>
	</parent>

2) Add dependencies
	
	<dependency>	
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter</artifactId>

		/* Here version is automatically inherited from parent, so no need to provide */ 

	</dependency>

3) Add plugin

	- Spring boot provided plugins to maven to build, run, test & package for war/jar with goal etc...

	<plugin>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-maven-plugin</artifactId> /* To build & execute spring boot app */
	</plugin>


- In order to migrate existing application, add these three tags in pom.xml
- To create new spring boot project, needs spring initializer tool which adds all the stuffs in pom.xml like start.spring.io
- Every spring boot application have entry point class with main method and application executes from this main method only.
- The entry point class must have annotated with @SpringBootApplication. 
- @SpringBootApplication consist of three annotations :
	[@Configuration / @SpringBootConfiguration + @ComponentScan + @EnableSpringBootConfiguration].


@SpringBootApplication
---------------------------------
	- class level annotation
	- entry point of spring boot application
	- combination of :
		- @SpringBootConfiguration (or SpringConfiguration - both are same)
		- @EnableAutoConfiguration (Automatically configures jars which are available in class path)
		- @ComponentScan
	- The class annotated with @SpringBootApplication, acts also as a configuration class and the class can contain bean configurations methods.
	- Spring boot application runs as a SpringApplication.

spring-boot-configuration module - contains auto configuration classes
	for e.g. 
	-----------
	spring-boot-starter-web - spring-boot-configuration module configures all the jars associated this starter dependency automatically.


@SpringBootApplication
public class DemoApp {
	public static void main(String args[]){
		
		SpringApplication.run(DemoApp.class, args);
		
		// BOOTSTRAPPING
		//-------------------
		//run is a static method and does the following internally :
		//1) creates ApplicationContext (A type of container which manages entire beans) - loads all the beans of the application to the 						ApplicationContext with the help of DemoApp.class.
		//2) registers CommandLinePropertySource bean (This class Converts command line arguments to spring application properties)
		//3) refreshes ApplicationContext with singleton beans
		//4) triggers CommandLineRunner bean classes

		//- Just before ready to run spring boot application, CommandLineRunner executes(If you want to execute any logic one time just before spring boot application is going to start. for e.g. - like load all the job schedules from database or to insert users with encrypted password for admin users to database.)
		- CommandLineRunner is an interface provides a method run().
		- We can define multiple CommandLineRunner by implementing in our classes, but needs provide order of execution else will run randomly.

		// These all for steps are called bootstrapping(initialising the application).
		
	}
}

CommandLineRunner implementation (by custom)
---------------------------------------------
@Component 
@Order(2) // Defines execution order for the class - low the number higher the priority
public class LoadSchedulesRunner implements CommandLineRunner {
	@Override
	public void run(String... args) {
		//logic
	}
}

@Component 
@Order(1)
public class DataRunner implements CommandLineRunner {
	@Override
	public void run(String... args) {
		//logic
	}
}

$mvn spring-boot:run //Maven uses Spring boot maven plugin to compile & run

$java -jar filename.jar

Deploy Docker image in cloud

CommandLinePropertySource
----------------------------
 - If any value passed by command line argument, it reads those & add to the 'Environment Object' of the application.
 
 - It is similar to write properties in application.properties/ application.yml

  
 

9505360660 - mohd. Basith. - Sathya Tech - 5000 - google pay
send screenshot of payment to 9100920092 whatsapp.

paid

-----------------------------------------------------------------


Spring Boot - Summary
-----------------------
# Why boot?
	- Zero/Less configuration
		* Earlier Spring has provided flexibility to define configurations in multiple ways like xml, annotations, java configuration classes.
	- Starter dependency
		* Boot provided combination of compatible dependency in a single starter dependency
	- Embeded server
		* Earlier had to deploy jar/war to server manually.
	- When application moves on from one environment to another then you had to change application properties manually.   
	
- Spring Boot is a new model to create spring applications, but it is not a new framework

- Features
	* Zero or Minimal configurations
	* Starter Dependencies
	* Embedded servers
	* Opinionated view - Default configuration with customisations 
	* profiles
	* actuators - Production ready features

- Requirements for Spring Boot		
	1) Java 8+
	2) Maven/ Gradle

- Changes to pom.xml
	1) Add parent tag
	2) Add starter dependencies
	3) add plugin
	
- If you want to migrate a spring application to spring boot application, you need to add the changes to pom.xml manually.

- A new spring boot applications are generated through spring initialiser tool, which automatically adds the required changes in pom.xml.


@SpringBootApplication
-------------------------
* Every spring boot application executes from java main(). 
* To make a class as an entry point for spring boot project, add @SpringBootApplication on class 
* @SpringBootApplication = @SpringBootConfiguration + @EnableAutoConfiguration + @ComponentScan
* Every spring boot application class is a configuration class, in which you can define bean methods to customize the configurations.
* In spring boot, we have auto configure module with a group of auto configuration classes which automatically adds the required bean configurations based on the jars available on classpath.

com.pack // base package - contains main method - does auto configure from its package.  
com.pack.service
com.pack.controller
com.pack.entity
com.pack.model
com.pack.dao
com.pack.utilities

* Bydefault, components auto scan starts from spring boot application's base package to its sub packages.
It can be customized with scanBasePackages element.
(If configuration available in package other than base package path) 

@SpringBootApplication(scanBasePackages={"package1", "package2", ...})

SpringApplication.run()
----------------------------
* Spring boot has provided SpringApplication class, to run a spring boot application as a spring based application from java main method.
* The run() has two parameters : 
	1) Spring Boot Application class Class object
	2) command-line arguments

for e.g.
----------
@SpringBootApplication
public class DemoApplication {
	psvm(String args[]) {
		SpringApplication.run(DemoApplication.class, args);
	}
}

Stereo type annotations - defines role of the class
----------------------------------------------------------
@Component - spring bean class
@Service
@Controller
@RestController
@Repository 
@Configuration - java configuration class

CommandLineRunner
---------------------
- Triggers just before running spring boot application.
- Multiple CommandLineRunner can be defined with run order.

STS(Spring Tools Suite) IDE - File - new Spring Starter Project 
Name - Demo1 | Type - Maven | Packaging - jar | Java Version - 8
Group(Organisation) - com.sathyatech
Artifact(Project Name) - Demo1
Version 1.1
package(Base package) - com.demo

Next - Spring Boot Version - 2.3.3 | Dependencies - ...if any like web, lombok etc. (If not add any dependency, it will be added Spring-Boot-Starter dependency only).

pom.xml - plugin(spring-boot-maven-plugib) - spring provided this plugin to build & run spring boot application.

Demo1Application.java - this class is created automatically according to the Project name.

@SpringBootApplication
public class Demo1Application {
	psvm(String args[]) {
		SpringApplication.run(Demo1Application.class, args);
	}
}

package com.demo.bean;
@Component
public class HelloWorldBean {
	public String sayHello() {
		return "Hello World";
	}
}

package com.demo.runner;
@Component
public class MyRunner implements CommandLineRunner{
	@Autowired //Object/collection dependencies - if bean is conflicting then use @Qualifier
	HelloWorldBean helloWorld;

	@Override
	public void run(String... args) throws Exception{
		System.out.println(helloWorld.sayHello());
	}
}

Go to main() class & run as java application.
or
manven - maven build ... - command = build
project - target - Demo1-1.1.jar
$ [go to project path]
$ java -jar target/Demo1-1.1.jar
or 
$ mvn spring-boot:run

If mvn is showing error like - not a command
- download maven, extract & set maven on environmental path
- apache-maven-3.5.2\bin : add this to path variable.
 
$ mvn --version
$ mvn clean package [clean - to clean previous build, package - packaging jar]
$ mvn spring-boot:run - to run boot project inside the project directory

Application properties is set by either of :
1) application.properties
2) application.yaml
3) command line argument
4) CommandLineRunner class

command line argument has two types
1) Optional arguments [contains key=value, starts with '--']
	for e.g.
	---------
	$ java -jar target/filename.jar --key=value

2) Non-optional arguments [contains only value]

	for e.g. 
	------------
	$ java -jar target/filename.jar --key=value --key=value nonoptional1 nonoption2


ApplicationRunner interface
--------------------------------
- like CommandLineRunner interface & it has also a run() but it takes ApplicationArguments

- run(ApplicationArguments args)

- ApplicationArguments separates Optional & non-optional command line arguments.

- If you want to set properties at the time of runtime then go for ApplicationRunner.

with @Values can be injected values to the bean - It is called value injection.


@Component
public class HelloWorldBean {
	//@Value("Hello World")
	@Value(${msg.key})
	String message;

	public String sayHello() {
		return message;
	}
}

application.properties
--------------------------
msg.key=Hello World!


- If we provide value at runtime with argument, it will override application properties value.
$ java -jar target/Demo-1.1.jar --msg.key="It's a boot application" [This message will be shown].

So, command line argument has high priority.

If properties file name is not "application.properties" then use @PropertySource(classpath:myfile.properties) in @SpringBootApplication class

create a spring core app : 
-----------------------------
package com.demo
@SpringBootApplication
public class Demo2Application {
	psvm(String args[]) {
		SpringApplication.run(Demo2Application.class, args);
	}
}

package com.demo.runner;
@Component
public class MyApplicationRunner implements ApplicationRunner {
	@Override
	public void run(ApplicationArguments args) throw Exception {
		//ApplicationArguments has separate methods for option & nonoption arguments 

		//To print all Non-option args
		List<String> nonOptionArgsList = args.getNonOptionArgs();
		sysout("Non-option args from command line : ");
		nonOptionArgsList.forEach(System.out::println);

		sysout("=====================");

		//To print all option args
		//One key can have multiple values.
		Set<String> optionArgsNames = args.getOptionNames();
		optionArgsNames.forEach((name)-> {
			List<String> optionArgValues = args.getOptionValues(name);
			System.out.print(name + " : "); //name
			optionArgValues.forEach(System.out::print+" "); //associated values
		}); 
	}
}

$ mvn spring-boot:run -Dspring-boot.run.arguments="--id=101 --name=Stahya,Shekher Amirpet Hyderabad"
or
$ java -jar target/Demo2-1.1.jar --id=101 --name=Stahya,Shekher Amirpet Hyderabad

$ java -jar target/Demo2-1.1.jar --id=101 --name=Stahya,Shekher Amirpet Hyderabad --id=10001

Note : id=10001 does not override id=101. It will keep both with coma sepearted


To Autowire Option & Non-Option args in a class
----------------------------------------------------

@Component
public class Warehouse {
	List<String> warehouseTypes;

	@Autowired
	ApplicationArguments args;

	public void addWarehouseTypes(){
		List<String> list = args.getNonOptionArgs();
		list.forEach(value->warehouse.add(value));
	}
}

Command Line Arguments
------------------------------
CommandLineRunner - run(String... args)
ApplicationRunner - run(ApplicationArguments args)

Command line arguments
1) option args [--key=value]
2) non-option args [value]

- application.properties - define arguments here at development time.

- Command Line Arguments override application.properties values.

For e.g with DI
------------------------
package com.demo.bean;
@Component
public class PolicyBean{

	@Value("${policy.company}")
	String policyCompany;
	
	List<String> policyTypes = new ArrayList<String>();

	@Autowired
	ApplicationArguments args;

	public void showDetails() {
		List<String> nonOptionArgs = args.getNonOptionArgs();
		nonOptionArgs.forEach((name)->{
			policyTypes.add(name);
		});
		
		sysout("Policy company: "+policyCompany);
		sysout("Policy Type: ");
		policyTypes.forEach(System.out::println);
	}
	
}

package com.demo.runner;

@Component
public class MyRunner implements CommandLineRunner {
	@Autowired
	PolicyBean policyBean;

	@Override
	public void run(String... args) throws Exception {
		policyBean.showDetails();
	}
}

application.pproperties
------------------------
policy.company=LIC

- package it 

$ java -jar target/Demo3-1.1.jar --policy.company="LIC Of India" "Endowment Plan" "Term Insurance Plan" "Money Back Plan"

- We can make the main class of spring boot app also a CommandLineRunner like this - because @SpringBootApplication is also a @Component : 
@SpringBootApplication 
public class Demo3Application implements CommandLineRunner {
	@Autowired
	PolicyBean policyBean;

	public static void main(String args[]){
		SpringApplication.run(Demo3Application.class, args);
	}

	@Override
	public void run(String... args) throws Exception {
		policyBean.showDetails();
	}
}


CommandLineRunner
---------------------
	- Implement this interface into a class to define a code to run before a spring boot application's bootstrapping is going to finish.
	- Just before a spring boot application becomes ready to use by the users, the command line runner beans of application will be executed.
	- You can define multiple CommandLineRunner and define the order of their executions with @Order.

ApplicationRunner
-------------------
	- It is also like CommandLineRunner only, but it provides a run() with ApplicationArguments parameters to access option and non-option arguments separately.
	- An option argument has a key-value. [--key=value]
	- An option argument has a value only. [without --]

	$ java -jar target/appname.jar --key=value --server.port=2020 --db.user=system IamNonOption1 "I am Non Option2"
	
	$ mvn spring-boot:run -Dspring-boot.run.arguments="--key=value --server.port=2020 --db.user=system IamNonOption1 'I am Non Option2'"


Spring-JDBC [spring-boot-starter-jdbc & DB Driver dependencies]
=================================================================== 
	- Checked exception
	- No boiler plate code
	- Provides an abstraction layer over JDBC - JdbcTemplate class
		- JdbcTemplate class depends on DataSource[interface].
			DataSource[interface] implementation :
				- DriverManagerDataSource class
				- HikariDataSource class

 
	
spring-jdbc project
------------------------
	pom.xml
	--------------------------
	- spring-boot-starter-jdbc(JDBC API) & Oracle Driver(ojdbc8) dependencies
	
	application.properties
	--------------------------
	spring.datasource.driver-class-name=oracle.jdbc.driver.OracleDriver
	spring.datasource.url=jdbc:oracle:thin:@localhost:1521:xs
	spring.datasource.username=system
	spring.datasource.password=tiger

	package com.demo.dao;
	public interface EmpDaoIntf {
		void updateEmp(double salary, int deptno);
		Map findEmpById(int empno);
		List<Map<String, Object>> findAll();
	}

	package com.demo.dao.impl;
	@Repository
	public class EmpDaoImpl implements EmpDaoIntf {

		@Autowired 
		JdbcTemplate jdbcTemplate;

		@Override
		void updateEmp(double salary, int deptno){
			jdbcTemplate.update("UPDATE EMP SET SAL=? WHERE DEPTNO=?", salary, deptno);
		}

		@Override
		Map findEmpById(int empno) {
			return jdbcTemplate.queryForMap("SELECT * FROM EMP WHERE EMPNO=?",empno); //Single record selection
		}

		@Override
		List<Map<String, Object>> findAll() {
			return jdbcTemplate.queryForList("SELECT * FROM EMP"); //Multi row records
		}
	}

	package com.demo.runner;
	@Component		
	public class MyRunner implements CommandLineRunner {
		@Autowired
		EmpDaoIntf intf;

		@Override
		public void run(String... args) throws Exception {
			intf.updateEmp(5999.0, 20);
			
			sysout(intf.findEmpById(7788));

			List<Map<String, Object>> list = intf.findAll();
			list.forEach(System.out::println); 
		}
	}
	
	run app 

Spring Boot MVC
==================
- Web applications can be created using Servlet & JSP technologies which provides tightly coupled solution.
- Model(data/business), view(presentation), controller(navigates between model & view).
- Front Controller (DispatcherServlet) - Controls each & every request

- In java MVC & MVC2 architectures are there.
	- In MVC(No Helper class), front controller contacts with appropriate Model directly then controller decides appropriate view.
	- In MVC2(Use Helper class), front controller servlet use Helper classes to identify Model & View classes. 
	- Spring MVC follows MVC2 architecture where need to configure servlet_name-servlet.xml and also need to add DispatcherServlet to web.xml 
		WEB-INF/ web.xml & <servlet_name-servlet.xml> files
		web.xml
		--------------
		<web-app>
			<servlet>
				<servlet-name>spring</servlet-name>
				<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
				<load-on-startup>1</load-on-startup> //for early load of servlet.
			</servlet>
			<servlet-mapping>
				<servlet-name>spring</servlet-name>
				<url-pattern>/</url-pattern>
			</servlet-mapping>
		</web-app>
	- Spring boot MVC - No need to configure web.xml or view response 

	spring MVC
	-----------
		Controller
		---------------
		@Controller - class level annotaion
		@RequestMapping/ @GetMapping/ @PutMapping/ @PostMapping/ @DeleteMapping - Method level annotations 
	

		@Controller
		public class UserController { //Controller Bean class

			//Old style
			@RequestMapping(value="/getUsers", method = RequestMethod.GET)
			public ModelAndView findUsers() {
				---
				---
			}

			//New Style
			@GetMapping("/getUsers")
			public ModelAndView findUsers() {// findUsers() is called Handler Method
				---
				---

				return new ModelAndView("view_name", "model_name", model_value); //String, String, Object -- will return view_name.jsp
				//InternalResourceViewResolver - to resolve a view name to actual view by adding a prefix & suffix - which needs to configure.
 
			}

		}
 

		1) DispatcherServlet calls HandllerMapping[RequestMappingHandlerMapping] bean to identify appropriate Controler
		2) HandllerMapping[RequestMappingHandlerMapping] bean returns appropriate Controller which associates the request to DispatcherServlet.
		3) Then DispatcherServlet calls that Controller bean.



	@Controller
	public class EmployeeController {
		@GetMapping("/index")
		public ModelAndView getIndexPage() {
			return new ModelAndView("index");
		}
	}
	
	@GetMapping("/employee/deptno") 
	public ModelAndView getEmployeesByDeptno(int deptno) {
		List<Employee> wmpList = service.findEmpsByDno(deptno);
		return new ModelAndView("show", "employee", empList);
	}


	- In SpringBoot by default InternalResourceViewResolver class is associated for View Resolver bean. It maps the view name to actual view.
	- InternalResourceViewResolver maps actual view by appending prefix & suffix.
		prefix = "/WEB-INF/views/"
		suffix = ".jsp"

		So, "/WEB-INF/views/show.jsp" will be the response for the DispatcherServelt, then DispatcherServelt renders show.jsp & responds.
	
		/WEB-INF/views/*.jsp

	- In SpringBoot prefix & suffix to be set in application.properties

	- Web applications are created to share resources. these resources may be a page/data/functionality.


	Current development scenario - No need to return ModelAndView object, just need to set model data to ModelMap & return view name 
	----------------------------------------------------------------------------------------------------------------------------------
	@GetMapping("/employees")
	public String getEmployees(ModelMap model) { //ModelMap is a type of Map only, instead of ModelMap it can be used Model/ Map**
		List<Employee> employeesList = service.findEmployees();
		model.addAttribute("employees", employeesList); //Model is set to ModelMap
		return "show"; //Returns only view name
	}
	
	**ModelMap extends LinkedHashMap implements Model [Model is from spring]

	Simple Spring MVC(No Spring boot) application development requires :
	------------------------------------------------------------------------
	1) MVC related dependencies to pom.xml
	2) add DispatcherServlet configuration to web.xml
	3) define spring configuration in dispatcher-servlet.xml
	4) deploy war on a server


	Spring boot MVC application development requires :
	-------------------------------------------------------
	1) add spring-boot-starter-web in pom.xml
	2) add server/ prefix/ suffix properties in application.properties
	3) run application

	Create application - starts.spring.io
	-------------------------------------------
	dependencies - 
	----------------
	1) spring-boot-starter-web
	2) //If jsp is a view
		<groupId>org.apache.tomcat.embed</groupId>
		<artifactId>tomcat-embed-jasper</artifactId>

	application.properties
	----------------------------
	server.port=2223
	server.servlet.context-path=/mvc
	spring.mvc.view.prefix=/WEB-INF/views/
	spring.mvc.view.suffix=.jsp

	
	package com.mvc.controller;
	@Controller
	public class HelloController {
		@GetMapping("/hello")
		public String returnWelcomePage() {
			return "welcome";
		}
	}

	create a jsp file in this directory :
	/src/main/webapp/WEB-INF/views/welcome.jsp
			
	welcome.jsp
	---------------
	<h1>Jai Ram G ki</h1>

	
	run & request as http://localhost:2223/mvc/hello


pom.xml
--------------
<dependency>
	<groupId>jstl</groupId>
	<artifactId>jstl</artifactId>
</dependency>

application.properties
---------------------------
server.servlet.context-path=/Train
spring.mvc.view.prefix=/WEB-INF/views
spring.mvc.view.suffix=.jsp


@Repository
public class TrainDaoImpl implements TrainDaoIntf {
	@Autowired
	JdbcTemplate jdbcTemplate;
	
	public Train findTrain(Integer trainno) {
		Map map = jdbcTemplate.queryForMap("select * from train_details where train_no = ?", trainno);
		
		Train train = new Train();
		BigDecimal bd = (BigDecimal)map.get("train_no");
		Integer trno = bd.intValue();
		train.setTrainno(trno);
		train.setSource(map.get("source").toString());
		train.setDestination(map.get("destination").toString());

		//Here RowMapper can be used to map object with POJO automatically.
	}
}

@Controller
public class TrainController {
	@Autowired
	TrainDaoIntf intf;

	@GetMapping("")
	public String {
		return "search";
	}

	@GetMapping("")
	public String searchTrainByNo(@RequestParam Integer trainno, Model model){
		Train train = intf.findTrain(trainno);
		model.addAttribute("train", train);
		retrun "result";
	}
	
	
}

result.jsp
--------------
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%> //EL - expression language/ jstl tag
<table>
	<tr>
		<th>Train#</th>
		<th>Source</th>
		<th>Destinaion</th>
		<th>Dept time</th>
		<th>Arr time</th>
	</tr>
	<tr>
		<td><c:out value="${train.trainno}"/></td>
		<td><c:out value="${train.source}"/></td>
		<td><c:out value="${train.destination}"/></td>
		<td><c:out value="${train.depttime}"/></td>
		<td><c:out value="${train.arrtime}"/></td>
	</tr>

</table>


Data Binding
=================
- By binding a UI form with application object, we achieve data binding.
- With JSP it can be achieved by adding the tag library as 
- WebDataBinder - DispatcherServlet calls WebDataBinder to bind UI controls to bean.

	<%@taglib uri="http://www.springframework.org/tags/form" prefix="form"%>

	<form:form action="xxx" modelAttribute="userData">//form tag - first form is prefix & second one is tag name
											    //add javaBeanObject(userData) with a name in ModelMap of spring

	@Controller
	public class UserController {

		@GetMapping("/userForm")
		public String getUserFormPage(Model model) {
			UserBean userBean = UserBean();
			model.addAttribute("userData", userBean);
			return "user";
		}
	}

On click of Submit button in UI, associated url is handled by the handler method to read the data,
which uses @ModelAttribute to bind method parameter to the model attribute.

Submit form -> @Controller -> 

@Controller
public class UserController {
	@GetMapping("/xxx")
	public String getUserPage() {
		//code
	}

	@PostMapping("/addUser")
	public String addUserDetails (@ModelAttribute UserBean userBean) {
		//code
	}
} 

	
Data Validation
===================
- Javascript validation is done on client side which is not much secure, for this need to validate data on server side.
- To validate data at server side, spring framework has not given any annotations.
- Sun has provided Bean Validation API(in interfaces) to validate data on java bean class with annotation.
- Hibernate has provided its implementation as Hibernate validator API.
- For this need to use dependency - spring-boot-starter-validation.
- WebDataBinder - DispatcherServlet calls WebDataBinder to bind UI controls to bean.

@AssertTrue
private boolean isActive; //Field value must be true

@AssertFalse
private boolean isDeleted; //Field value must be false

@NotEmpty //Can be applied only in String field
String userName; //userName should not be empty. else validation error.

@Size(min=5, max=10) //Can be applied only in String field
String password; 

@NotNull 
Date dob;

@NotNull //can be applied on objects, enum etc.
Gender gender;

@NotEmpty
@Email
String email;

@Min(18)
@Max(21)
Integer age; //@Min, @Max can be used with Integer, int, short, long.

@DecimalMin(15.15)
@DecimalMax(25.25)
Double price; // For decimal(float/ double)

@Past
@Future
Date field; // With date fields

@Pattern(regex="")
String code; // Can be applied on String field only

^ = used to match beginning of the value.
^[A-Z]

$ = used to match end of the value.
[0-9]$

* = 0 or multiple characters.
[a-z]*

+ = 1 or multiple characters.

[a-z]{10} = should be 10 lower case letters.
[a-z]{5,8} = minimum 5 & maximum 8 lower chars.

@Pattern(regex="^[A-Z][a-z]*")
String userName; //first char would be capital & rest of the char should small.

Handling error message
--------------------------
- should be defined in "messages.properties" file(file name must be messages.properties) & put this file in resources directory with application.properties.
- must be followed below convention for mesage :
	constraint.commandname.field=error message

	for e.g.
	---------------
	NotEmpty.userBean.userName=Username is required. //userBean is ModelAttribute name.

	in jsp
	---------------
	<form:errors/> //This tag is used to show the error message at a time or nearby each & every fields.


- BindingResult object stores all the validation errors.
	@PostMapping("/xxx")
	public String doRegister(@Valid @ModelAttribute UserBean userBean, BindingResult result){
		//@ModelAttribute binds method parameter to ModelAttribute
		//@Valid is indicating that the parameter bean is validated
		//This handler method requires BindingResult object to store all the error messages while validate.
		if(result.hasError()){
			return "registration";//Returning same page, error messages will be appended by BindingResult.
		}
		else
		{
			//code
		}
	}


Spring email API 
-------------------
JavaMailSender interface - JavaMailSenderImpl class - with SMTP server
- To send email without attachment - SimpleMailMessage class is used

Example[register-login system]
---------------------------------
If user not registered, system should show error message in the page & redirects to register by entering email.

index.jsp [http://localhost:8080/crm/index]
--------------------------------------------
DispatcherServlet(stops request) 	<-> HandlerMapping
						<-> RegisterController
						<-> ViewResolver
						->  view -> New User? Sign Up -> DS -> RegisterController -> view(register.jsp) -> 	First Name__________
								 Existing User? Sign in									Last Name___________
																					email_______________
																							submit

Submit -> DS -> RegisterController -> EmailService - send success email to user.

Login -> DS -> LoginController -> success.jsp/ error/login.jsp


Customer registration application with spring email, validation & data binding
================================================================================
project name = crm
package = com.crm
dependencies = JDBC API, Spring Web, Validation, Oracle Driver(ojdbc8), Java Mail Sender(spring-boot-starter-mail), org.apache.tomcat.embed(tomcat-embed-jasper) & jstl(jstl) 1.2

src/main/webapp/WEB-INF/views

com.crm.controller
com.crm.model
com.crm.service
com.crm.dao
com.crm.dao.impl
com.crm.service

@Repository
public class RegisterDaoImpl implements IRegisterDao {
	@Autowired
	JdbcTemplate jdbcTemplate;
	
	public boolean saveCustomer(CustomerBean customerBean){
		int count = jdbcTemplate.queryForObject("Select count(*) from customer_tab where email=?", Integer.class, customerBean.getEmail());
		if(count==1){
			return false;
		}
		else{
			jdbcTemplate.update("insert into customer_tab(email, first_name, last_name) values(?,?,?)", );
			return true;
		}
	}
	
}

@Component
public class RegisterController {
	@Autowired
	EmailService emailService;

	@Autowired
	IRegisterDao registerDao;

	@GetMaipping("/index")
	public String getIndexPage() {
		return "index";
	}

	@GetMapping("/register") 
	public String getRegisterPage(Model model){
		CustomerBean customerBean = new CustomerBean();
		model.addAttribute("custBean", customerBean); //adding customerBean to model for Data Binding with UI
		return "register";
	}

	@PostMapping("/save")
	public String registerCustomer(@Valid @ModelAttribute("custBean") CustomerBean customerBean, BindingResult result, Model model, HttpServletRequest request) {
		if(result.hasErrors()) {
			return "register";
		}
		else{
			boolean flag = registerDao.saveCustomer(customerBean);
			if(flag==false){
				model.addAttribute("message", "Customer already registerd. try another Id");
				return "register";
			}
			else{
				//send email to customer for register
				String name = customerBean.getFirstName()+" "+customerBean.getLastName();
				emailService.sendEmailToCustomer(customerBean.getEmail(), name);
				return "registrationSuccess";
			}
		}
	}
}

@Service
public class EmailService {
	@Autowired
	JavaMailSender mailSender;

	public void sendEmailToCustomer(String mailId, String name){
		SimpleMailMessage mailMessage = new SimpleMailMessage();
		mailMessage.setTo(mailId);
		mailMessage.setSubject("");
		mailMessage.setText(name+"");
		mailMessage.send();
	}
}

package com.crm.model;
public class CustomerBean {
	@NotEmpty
	private String firstName;
	
	@NotEmpty
	private String lastName;
	
	@NotEmpty
	@Email
	String email;

	@Pattern(regexp="^[a-z][a-z0-9#@!]*")
	@Size(min=8, max=15)
	private String password;

	@Min(21)
	@Max(35)
	@NotNull
	private Integer age;

	@NotNull
	private Gender gender;

	@NotNull
	private String country;

	@NotNull
	@Past
	@DateTimeFormat(pattern="yyyy-MM-dd")
	private Date dateOfBirth;

	@NotNull
	private Long contactNumber;

	private Map<String, String> countries = new HashMap<>();
	
	//assign countries in constructor
	public CustomerBean() {
		//put some countries values in map.
	}
	
}

public enum Gender {
	MALE, FEMALE, OTHER
}

@Controller
public class LoginController {
	@Autowired
	ILoginDao dao;
	
	@GetMapping("/login")
	public String getLoginPage(Model model){
		model.addAttribute("loginBean", new LoginBean());
		return "login";
	}
	
	@PostMapping("/userLogin")
	public String userLogin(@ModelAttribute LoginBean loginBean, Model model) {
		boolean flag = dao.loginCheck(loginBean.getEmail(), loginBean.getPassword());
		if(flag==false){
			model.addAttribute("msg", "Bad Credential");
			return "login";
		}
		else{
			return "loginSuccess";
		}
	}
}

@Repository
public class LoginDaoImpl implements ILoginDao {
	@Autowired
	JdbcTemplate jdbcTemplate;

	public boolean loginCheck(String email, String password){
		
	}
}

public class LoginBean {
	private String email;
	private String password;

	//Getter-Setter
}


index.jsp
-----------
New User? <a href="register">Sign UP</a><br>
Existing User? <a href="login">Sign In</a>

register.jsp
---------------
<%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>
<%@taglib uri="http://www.springframework.org/tags/form" prefix="form"%>

<c:if test="${message ne null}">
	<c:out value="${message}"/>
</c:if>


<form:form action="save" method="post" modelAttribute="custBean"> //save is a url
<table>
	<tr>
		<td>FirtName</td>
		<td><form:input path="firstName"/></td>
		<td style="color:red"><form:errors path="firstName"/></td>
	</tr>
	
	---
	---
	---
	<tr>
		<td>DOB</td>
		<td><form:input type="date" path="dateOfBirth"/></td>
		<td style="color:red"><form:errors path="dateOfBirth"/></td>
	</tr>

	<tr>
		<td>Country</td>
		<td>
			<form:select path="country"/> 
				<form:option value="">--select country--</form:option>
				<form:options items="${cutBean.countries}"/> //for data loop
			</form:select>
		</td>
	</tr>
</table>
</form:form>

registrationSuccess.jsp
----------------------------
You have registered successfully! Now go to index page.
<a href="index">Home</a>

login.jsp
---------------
<c:if test=${}>
<form:form action="userLogin" method="post" modelAttribute="loginBean">
	<table>
		Email
		Password
		Submit
	</table>
</form:form>

messages.properties
-------------------------------
#error messages

NotEmpty.custBean.firstName=First Name is required

NotEmpty.custBean.lastName=Last Name is required

NotEmpty.custBean.email=Email is required
Email.custBean.email=Invalid email

Min.custBean.age=Age must be >= 21
Max.custBean.age=Age must be <= 25


application.properties
--------------------------
server.port=2221
server.servlet.context-path=/CRM
spring.mvc.view.prefix=/WEB-INF/views/
spring.mvc.view.suffix=.jsp

#DataSource properties
spring.datasource.driver-class-name=oracle.jdbc.driver.OracleDriver
spring.datasource.url=jdbc:oracle:thin:@localhost:1521:xe
spring.datasource.username=xxx
spring.datasource.password=xxx

#Email SMTP properties
spring.mail.host=smtp.gmail.com
spring.mail.port=587
spring.mail.username=
spring.mail.password=
spring.mail.properties.mail.smtp.starttls.enable=true
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.ssl.trust=smtp.gmail.com

#go to email settings, privacy & enable less secure app access



Spring Boot Data JPA
==========================
- There are a various ways to connect spring application with database

	# Spring data access module provides for CRUD operations(Spring's aim to eliminate Dao implementation class):
		1) spring-jdbc-api 
		2) spring-orm-api

	Why Spring Data?
	-------------------
	- Spring's aim to eliminate Dao implementation class from user point of view. Only need to create a Dao interface.
	- Only need to declare methods(additional operations if required) in Dao interface.
	- All the declared methods implementation is provided by spring data at runtime.

	Spring Data Project[Main Project]
	--------------------------------------
		# Spring Data Commons [PagingAndSortingRepository + CrudRepository interfaces] [core-project] - Contains common behaviours 
		- JPA [] [sub-project]
		- MongoDb [MongoRepository] [sub-project]
		- Redis [sub-project]
		- Couchbase [sub-project]
		- Casandra [sub-project]

	* PagingAndSortingRepository extends CrudRepository

		#CrudRepository
		- save(entity)
		- flush() - To sync with database
		- deleteById(Id)
		- deleteAll()
		- findById(Id)
		- findAll()
		- existById(Id)

		#PagingAndSortingRepository
		- findAll(Sort sort)
		- findAll(Pageable pageable)

	* JPA(Java Persistence API specification from Sun to map java classes with table & JPQL) [JpaRepository interface]
		- JPQL(Java Persistence Query Language)
		** JpaRepository extends PagingAndSortingRepository ( -> CrudRepository)

		- By default Spring boot uses Hibernate as a JPA Provider.


	- One application may have many Entity; For each Entity should have separate Repository would be there to perform CRUD operations.


	For e.g
	-------------
	@Entity
	public class Stock {
		
	}

	@Repository
	public interface StockRepository extends JpaRepository<Stock, Entity_Id_data_type>{}
	
	@Entity
	public class Warehouse{
		
	}

	@Repository
	public interface WarehouseRepository extends JpaRepository<Warehouse, Integer>{}


	- Need to create separate Repository for each Entity.
	

class material link-> [https://groups.google.com/forum/#!forum/test_examples]

 
Need to consider for SPRING DATA JPA project
-----------------------------------------------
1) Enable JpaRepository [<jpa:repositories>]
2) configure DataSource bean
3) configure LocalContainerEntityManagerFactory bean
4) configure HibernateJpaVendorAdaptor
5) add multiple dependencies to pom.xml


Need to consider for SPRING BOOT DATA JPA project
---------------------------------------------------
1) add spring-boot-starter-data-jpa
2) create Repository interfaces


Query creation Approaches
-----------------------------
1) Query creation by method name
2) Query creation using @Query
3) query creation using @NamedQuery

# Query creation by method name keywords:
	1) findBy
	2) getBy
	3) readBy
	4) queryBy	

	keyword+DataMember+<Operator>

@Entity
@Data
public class Passenger {
	@Id
	private Integer passengerId;
	private String firstName;
	private String lastName;
	private String email;
	private String contactNumber;
	private Integer seatNumber;
}

@Repository
public interface PassangerRepository extends JpaRepository<Passenger, Integer>{
	//JpaRepository<Entity_class_name, data_type_of_Id_field>

	Passenger findByEmail(String email);
	
	List<Passenger> findByFirstName(String firstName);

	List<Passenger> findByEmailOrContactNumber(String email, Long contactNumber);

	List<Passenger> findBySeatBetween(Integer seat1, Integer seat2);

	List<Passenger> findByLastNameOrderByFirstNameAsc(String lastName);

	List<Passenger> findBySeatNumberLt(Integer seatNumber);	

	List<Passenger> findBySeatNumberGreaterThanEqual(Integer seatNumber);

}
	
save()
saveAndFlush() // For both purposes- save or update
deleteById()
deleteAll()
existById()
findById()
findAll()


Can we use @OneToMany relation in Entity to fetch all data in Spring Boot Data JPA?
Can we create Join related query by method?

# Query creation using @Query
---------------------------------
JPQL(Java Persistence Query Language)/ SQL

select * from emp;// SQL QUERY
select e from Employee e; // JPQL QUERY - works on Entity classes

select empno, sal from emp;//SQL 
select e.empNumber, e.salary from Employee e;//JPQL

select * from emp where deptno=?//SQL
select e from Employee e where e.deptNumber=?1//JPQL [?1...?n where 1 to n is index parameter]

@Repository
public interface Employee extends JpaRepository<Employee, Integer>{
	
	//JPQL - with index parameters(?1)
	@Query("select e from Employee e where e.deptNumber=?1")
	List<Employee> getEmpsByDeptno(Integer deptno); //any method name can be used here

	//JPQL - with named parameters(:name) - more readable
	@Query("select e from Employee e where e.deptNumber=:deptno and e.empSal=:sal")
	List<Employee> getEmployees(Integer dno, double sal);
	or
	List<Employee> getEmployee(@Param("deptno") Integer dno, @Param("sal") Double sal);


	//JPQL
	@Query("select e.empNumber, e.empSal from Employee e") //Partial select query - returns List<Object[]>, array will contain empNum & sal
	List<Object[]> readEmployees();


	//SQL
	@Query(value="select * from emp where sal>?", nativeQuery=true)//need to pass second argument as "nativeQuery=true" in case of SQL query
	List<Employee> findEmpBySalary(double sal);
	
}

Query creation using @NamedQuery
------------------------------------
- Write/define Named Query in Entity class & add the same name in method in multiple repository to execute the query.
- JPQL query

@Entity
@NamedQuery(name="Employee.fetchEmpsByDeptno", query="select e from Employee e where e.deptNumber=?1")
//naming convention for name - Entity_class_name.method_name
@Table(name="emp")
public class Employee {
	---
	---
	---
}

@Repository
public interface EmployeeRepository extends JpaRepository<Employee, Integer>{
	List<Employee> fetchEmpsByDeptno(Integer dno);
}

Multiple named query - JPQL
------------------------------
@Entity
@NamedQueries({
	@NamedQuery(name="xxx", query="yyy"),
	@NamedQuery(name="xxxx", query="yyy")
})
@Table(name="emp")
public class Employee {
	---
	---
	---
}


Query creation using @NamedNativeQuery
----------------------------------------
- Write/define Named Native Query in Entity class & add the same name in method in multiple repository to execute the query.
- SQL query

@Entity
@NamedNativeQuery(name="Employee.fetchEmpsByDeptno", query="select * from emp where deptno=?1")
//naming convention for name - Entity_class_name.method_name
@Table(name="emp")
public class Employee {
	---
	---
	---
}

@Repository
public interface EmployeeRepository extends JpaRepository<Employee, Integer>{
	List<Employee> fetchEmpsByDeptno(Integer dno);
}

Multiple named native query - SQL Queries
--------------------------------------------
@Entity
@NamedNativeQueries({
	@NamedNativeQuery(name="nxxx", query="yyy"),
	@NamedNativeQuery(name="nxxxx", query="yyy")
})
@Table(name="emp")
public class Employee {
	---
	---
	---
}









