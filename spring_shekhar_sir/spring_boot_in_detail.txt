class material link-> [https://groups.google.com/forum/#!forum/test_examples]

Spring Boot is a new model to develop spring applications.

Features
-----------
1) Flexibility over configuration - Annotation, java config classes or zero configurations.

2) Starters dependency - (Combination of required jars)
	- A group of related dependencies with appropriate versions.

3) Embedded server - (Tomcat, Jetty etc.)

4) Profiles (To make application compatible for different environments - just need to activate the related profile at the time of development)

5) Actuators - Inside details of application during runtime like heap size, memory information, server status etc.


SpringBoot Core/ AOP
SpringBoot MVC
SpringBoot Data JPA
SpringBoot Data MongoDB
SpringBoot Security
SpringBoot Restful Web services
SpringBoot Data Redis
SpringBoot Security Oath2
SpringBoot Profiles
SpringBoot Actuator
SpringBoot Batch
SpringBoot Kafka

Monolithic application - Single jar/ war for whole application
------------------------------------------------------------------
- It has the following drawbacks

	1) Large App 
		- Increase development time, may cause downtime during deployment even though changes are very small.
		- Large deployment & startup time
	2) Scaling
		- Difficult to handle when large traffic for a single module, entire application goes down.

	3) One Technology Stack -Entire development is done only with one technology, Other language/ technology support not available.

Solution of Monolithic approach is - Micro-services.

Micro-services
------------------
- Split of large system into smalls.
- Independent responsibility for each micro services.
- Scaling [If one micro-service is having downtime/ load - only that particular micro-service can be scaled up without interrupting others.]
- Multi language development possible (Interoperability). 


pom.xml
===============
1) Add <parent> tag - above dependency tag
	
	<parent> 
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.3.1.RELEASE</version>
	</parent>

2) Add dependencies
	
	<dependency>	
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter</artifactId>

		/* Here version is automatically inherited from parent, so no need to provide */ 

	</dependency>

3) Add plugin

	- Spring boot provided plugins to maven to build, run, test & package for war/jar with goal etc...

	<plugin>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-maven-plugin</artifactId> /* To build & execute spring boot app */
	</plugin>


- In order to migrate existing application, add these three tags in pom.xml
- To create new spring boot project, needs spring initializer tool which adds all the stuffs in pom.xml like start.spring.io
- Every spring boot application have entry point class with main method and application executes from this main method only.
- The entry point class must have annotated with @SpringBootApplication. 
- @SpringBootApplication consist of three annotations :
	[@Configuration / @SpringBootConfiguration + @ComponentScan + @EnableSpringBootConfiguration].


@SpringBootApplication
---------------------------------
	- class level annotation
	- entry point of spring boot application
	- combination of :
		- @SpringBootConfiguration (or SpringConfiguration - both are same)
		- @EnableAutoConfiguration (Automatically configures jars which are available in class path)
		- @ComponentScan
	- The class annotated with @SpringBootApplication, acts also as a configuration class and the class can contain bean configurations methods.
	- Spring boot application runs as a SpringApplication.

spring-boot-configuration module - contains auto configuration classes
	for e.g. 
	-----------
	spring-boot-starter-web - spring-boot-configuration module configures all the jars associated this starter dependency automatically.


@SpringBootApplication
public class DemoApp {
	public static void main(String args[]){
		
		SpringApplication.run(DemoApp.class, args);
		
		// BOOTSTRAPPING
		//-------------------
		//run is a static method and does the following internally :
		//1) creates ApplicationContext (A type of container which manages entire beans) - loads all the beans of the application to the 						ApplicationContext with the help of DemoApp.class.
		//2) registers CommandLinePropertySource bean (This class Converts command line arguments to spring application properties)
		//3) refreshes ApplicationContext with singleton beans
		//4) triggers CommandLineRunner bean classes

		//- Just before ready to run spring boot application, CommandLineRunner executes(If you want to execute any logic one time just before spring boot application is going to start. for e.g. - like load all the job schedules from database or to insert users with encrypted password for admin users to database.)
		- CommandLineRunner is an interface provides a method run().
		- We can define multiple CommandLineRunner by implementing in our classes, but needs provide order of execution else will run randomly.

		// These all four steps are called bootstrapping(initialising the application).
		
	}
}

CommandLineRunner implementation (by custom)
---------------------------------------------
@Component 
@Order(2) // Defines execution order for the class - low the number higher the priority
public class LoadSchedulesRunner implements CommandLineRunner {
	@Override
	public void run(String... args) {
		//logic
	}
}

@Component 
@Order(1)
public class DataRunner implements CommandLineRunner {
	@Override
	public void run(String... args) {
		//logic
	}
}

$mvn spring-boot:run //Maven uses Spring boot maven plugin to compile & run

$java -jar filename.jar

Deploy Docker image in cloud

CommandLinePropertySource
----------------------------
 - If any value passed by command line argument, it reads those & add to the 'Environment Object' of the application.
 
 - It is similar to write properties in application.properties/ application.yml

  
 

9505360660 - mohd. Basith. - Sathya Tech - 5000 - google pay
send screenshot of payment to 9100920092 whatsapp.

paid

-----------------------------------------------------------------


Spring Boot - Summary
-----------------------
# Why boot?
	- Zero/Less configuration
		* Earlier Spring has provided flexibility to define configurations in multiple ways like xml, annotations, java configuration classes.
	- Starter dependency
		* Boot provided combination of compatible dependency in a single starter dependency
	- Embeded server
		* Earlier had to deploy jar/war to server manually.
	- When application moves on from one environment to another then you had to change application properties manually.   
	
- Spring Boot is a new model to create spring applications, but it is not a new framework

- Features
	* Zero or Minimal configurations
	* Starter Dependencies
	* Embedded servers
	* Opinionated view - Default configuration with customisations 
	* profiles
	* actuators - Production ready features

- Requirements for Spring Boot		
	1) Java 8+
	2) Maven/ Gradle

- Changes to pom.xml
	1) Add parent tag
	2) Add starter dependencies
	3) add plugin
	
- If you want to migrate a spring application to spring boot application, you need to add the changes to pom.xml manually.

- A new spring boot applications are generated through spring initialiser tool, which automatically adds the required changes in pom.xml.


@SpringBootApplication
-------------------------
* Every spring boot application executes from java main(). 
* To make a class as an entry point for spring boot project, add @SpringBootApplication on class 
* @SpringBootApplication = @SpringBootConfiguration + @EnableAutoConfiguration + @ComponentScan
* Every spring boot application class is a configuration class, in which you can define bean methods to customize the configurations.
* In spring boot, we have auto configure module with a group of auto configuration classes which automatically adds the required bean configurations based on the jars available on classpath.

com.pack // base package - contains main method - does auto configure from its package.  
com.pack.service
com.pack.controller
com.pack.entity
com.pack.model
com.pack.dao
com.pack.utilities

* Bydefault, components auto scan starts from spring boot application's base package to its sub packages.
It can be customized with scanBasePackages element.
(If configuration available in package other than base package path) 

@SpringBootApplication(scanBasePackages={"package1", "package2", ...})

SpringApplication.run()
----------------------------
* Spring boot has provided SpringApplication class, to run a spring boot application as a spring based application from java main method.
* The run() has two parameters : 
	1) Spring Boot Application class Class object
	2) command-line arguments

for e.g.
----------
@SpringBootApplication
public class DemoApplication {
	psvm(String args[]) {
		SpringApplication.run(DemoApplication.class, args);
	}
}

Stereo type annotations - defines role of the class
----------------------------------------------------------
@Component - spring bean class
@Service
@Controller
@RestController
@Repository 
@Configuration - java configuration class

CommandLineRunner
---------------------
- Triggers just before running spring boot application.
- Multiple CommandLineRunner can be defined with run order.

STS(Spring Tools Suite) IDE - File - new Spring Starter Project 
Name - Demo1 | Type - Maven | Packaging - jar | Java Version - 8
Group(Organisation) - com.sathyatech
Artifact(Project Name) - Demo1
Version 1.1
package(Base package) - com.demo

Next - Spring Boot Version - 2.3.3 | Dependencies - ...if any like web, lombok etc. (If not add any dependency, it will be added Spring-Boot-Starter dependency only).

pom.xml - plugin(spring-boot-maven-plugib) - spring provided this plugin to build & run spring boot application.

Demo1Application.java - this class is created automatically according to the Project name.

@SpringBootApplication
public class Demo1Application {
	psvm(String args[]) {
		SpringApplication.run(Demo1Application.class, args);
	}
}

package com.demo.bean;
@Component
public class HelloWorldBean {
	public String sayHello() {
		return "Hello World";
	}
}

package com.demo.runner;
@Component
public class MyRunner implements CommandLineRunner{
	@Autowired //Object/collection dependencies - if bean is conflicting then use @Qualifier
	HelloWorldBean helloWorld;

	@Override
	public void run(String... args) throws Exception{
		System.out.println(helloWorld.sayHello());
	}
}

Go to main() class & run as java application.
or
manven - maven build ... - command = build
project - target - Demo1-1.1.jar
$ [go to project path]
$ java -jar target/Demo1-1.1.jar
or 
$ mvn spring-boot:run

If mvn is showing error like - not a command
- download maven, extract & set maven on environmental path
- apache-maven-3.5.2\bin : add this to path variable.
 
$ mvn --version
$ mvn clean package [clean - to clean previous build, package - packaging jar]
$ mvn spring-boot:run - to run boot project inside the project directory

Application properties is set by either of :
1) application.properties
2) application.yaml
3) command line argument
4) CommandLineRunner class

command line argument has two types
1) Optional arguments [contains key=value, starts with '--']
	for e.g.
	---------
	$ java -jar target/filename.jar --key=value

2) Non-optional arguments [contains only value]

	for e.g. 
	------------
	$ java -jar target/filename.jar --key=value --key=value nonoptional1 nonoption2


ApplicationRunner interface
--------------------------------
- like CommandLineRunner interface & it has also a run() but it takes ApplicationArguments

- run(ApplicationArguments args)

- ApplicationArguments separates Optional & non-optional command line arguments.

- If you want to set properties at the time of runtime then go for ApplicationRunner.

with @Values can be injected values to the bean - It is called value injection.


@Component
public class HelloWorldBean {
	//@Value("Hello World")
	@Value(${msg.key})
	String message;

	public String sayHello() {
		return message;
	}
}

application.properties
--------------------------
msg.key=Hello World!


- If we provide value at runtime with argument, it will override application properties value.
$ java -jar target/Demo-1.1.jar --msg.key="It's a boot application" [This message will be shown].

So, command line argument has high priority.

If properties file name is not "application.properties" then use @PropertySource(classpath:myfile.properties) in @SpringBootApplication class

create a spring core app : 
-----------------------------
package com.demo
@SpringBootApplication
public class Demo2Application {
	psvm(String args[]) {
		SpringApplication.run(Demo2Application.class, args);
	}
}

package com.demo.runner;
@Component
public class MyApplicationRunner implements ApplicationRunner {
	@Override
	public void run(ApplicationArguments args) throw Exception {
		//ApplicationArguments has separate methods for option & nonoption arguments 

		//To print all Non-option args
		List<String> nonOptionArgsList = args.getNonOptionArgs();
		sysout("Non-option args from command line : ");
		nonOptionArgsList.forEach(System.out::println);

		sysout("=====================");

		//To print all option args
		//One key can have multiple values.
		Set<String> optionArgsNames = args.getOptionNames();
		optionArgsNames.forEach((name)-> {
			List<String> optionArgValues = args.getOptionValues(name);
			System.out.print(name + " : "); //name
			optionArgValues.forEach(System.out::print+" "); //associated values
		}); 
	}
}

$ mvn spring-boot:run -Dspring-boot.run.arguments="--id=101 --name=Stahya,Shekher Amirpet Hyderabad"
or
$ java -jar target/Demo2-1.1.jar --id=101 --name=Stahya,Shekher Amirpet Hyderabad

$ java -jar target/Demo2-1.1.jar --id=101 --name=Stahya,Shekher Amirpet Hyderabad --id=10001

Note : id=10001 does not override id=101. It will keep both with coma sepearted


To Autowire Option & Non-Option args in a class
----------------------------------------------------

@Component
public class Warehouse {
	List<String> warehouseTypes;

	@Autowired
	ApplicationArguments args;

	public void addWarehouseTypes(){
		List<String> list = args.getNonOptionArgs();
		list.forEach(value->warehouse.add(value));
	}
}

Command Line Arguments
------------------------------
CommandLineRunner - run(String... args)
ApplicationRunner - run(ApplicationArguments args)

Command line arguments
1) option args [--key=value]
2) non-option args [value]

- application.properties - define arguments here at development time.

- Command Line Arguments override application.properties values.

For e.g with DI
------------------------
package com.demo.bean;
@Component
public class PolicyBean{

	@Value("${policy.company}")
	String policyCompany;
	
	List<String> policyTypes = new ArrayList<String>();

	@Autowired
	ApplicationArguments args;

	public void showDetails() {
		List<String> nonOptionArgs = args.getNonOptionArgs();
		nonOptionArgs.forEach((name)->{
			policyTypes.add(name);
		});
		
		sysout("Policy company: "+policyCompany);
		sysout("Policy Type: ");
		policyTypes.forEach(System.out::println);
	}
	
}

package com.demo.runner;

@Component
public class MyRunner implements CommandLineRunner {
	@Autowired
	PolicyBean policyBean;

	@Override
	public void run(String... args) throws Exception {
		policyBean.showDetails();
	}
}

application.pproperties
------------------------
policy.company=LIC

- package it 

$ java -jar target/Demo3-1.1.jar --policy.company="LIC Of India" "Endowment Plan" "Term Insurance Plan" "Money Back Plan"

- We can make the main class of spring boot app also a CommandLineRunner like this - because @SpringBootApplication is also a @Component : 
@SpringBootApplication 
public class Demo3Application implements CommandLineRunner {
	@Autowired
	PolicyBean policyBean;

	public static void main(String args[]){
		SpringApplication.run(Demo3Application.class, args);
	}

	@Override
	public void run(String... args) throws Exception {
		policyBean.showDetails();
	}
}


CommandLineRunner
---------------------
	- Implement this interface into a class to define a code to run before a spring boot application's bootstrapping is going to finish.
	- Just before a spring boot application becomes ready to use by the users, the command line runner beans of application will be executed.
	- You can define multiple CommandLineRunner and define the order of their executions with @Order.

ApplicationRunner
-------------------
	- It is also like CommandLineRunner only, but it provides a run() with ApplicationArguments parameters to access option and non-option arguments separately.
	- An option argument has a key-value. [--key=value]
	- An option argument has a value only. [without --]

	$ java -jar target/appname.jar --key=value --server.port=2020 --db.user=system IamNonOption1 "I am Non Option2"
	
	$ mvn spring-boot:run -Dspring-boot.run.arguments="--key=value --server.port=2020 --db.user=system IamNonOption1 'I am Non Option2'"


Spring-JDBC [spring-boot-starter-jdbc & DB Driver dependencies]
=================================================================== 
	- Checked exception
	- No boiler plate code
	- Provides an abstraction layer over JDBC - JdbcTemplate class
		- JdbcTemplate class depends on DataSource[interface].
			DataSource[interface] implementation :
				- DriverManagerDataSource class
				- HikariDataSource class

 
	
spring-jdbc project
------------------------
	pom.xml
	--------------------------
	- spring-boot-starter-jdbc(JDBC API) & Oracle Driver(ojdbc8) dependencies
	
	application.properties
	--------------------------
	spring.datasource.driver-class-name=oracle.jdbc.driver.OracleDriver
	spring.datasource.url=jdbc:oracle:thin:@localhost:1521:xs
	spring.datasource.username=system
	spring.datasource.password=tiger

	package com.demo.dao;
	public interface EmpDaoIntf {
		void updateEmp(double salary, int deptno);
		Map findEmpById(int empno);
		List<Map<String, Object>> findAll();
	}

	package com.demo.dao.impl;
	@Repository
	public class EmpDaoImpl implements EmpDaoIntf {

		@Autowired 
		JdbcTemplate jdbcTemplate;

		@Override
		void updateEmp(double salary, int deptno){
			jdbcTemplate.update("UPDATE EMP SET SAL=? WHERE DEPTNO=?", salary, deptno);
		}

		@Override
		Map findEmpById(int empno) {
			return jdbcTemplate.queryForMap("SELECT * FROM EMP WHERE EMPNO=?",empno); //Single record selection
		}

		@Override
		List<Map<String, Object>> findAll() {
			return jdbcTemplate.queryForList("SELECT * FROM EMP"); //Multi row records
		}
	}

	package com.demo.runner;
	@Component		
	public class MyRunner implements CommandLineRunner {
		@Autowired
		EmpDaoIntf intf;

		@Override
		public void run(String... args) throws Exception {
			intf.updateEmp(5999.0, 20);
			
			sysout(intf.findEmpById(7788));

			List<Map<String, Object>> list = intf.findAll();
			list.forEach(System.out::println); 
		}
	}
	
	run app 

Spring Boot MVC
==================
- Web applications can be created using Servlet & JSP technologies which provides tightly coupled solution.
- Model(data/business), view(presentation), controller(navigates between model & view).
- Front Controller (DispatcherServlet) - Controls each & every request

- In java MVC & MVC2 architectures are there.
	- In MVC(No Helper class), front controller contacts with appropriate Model directly then controller decides appropriate view.
	- In MVC2(Use Helper class), front controller servlet use Helper classes to identify Model & View classes. 
	- Spring MVC follows MVC2 architecture where need to configure servlet_name-servlet.xml and also need to add DispatcherServlet to web.xml 
		WEB-INF/ web.xml & <servlet_name-servlet.xml> files
		web.xml
		--------------
		<web-app>
			<servlet>
				<servlet-name>spring</servlet-name>
				<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
				<load-on-startup>1</load-on-startup> //for early load of servlet.
			</servlet>
			<servlet-mapping>
				<servlet-name>spring</servlet-name>
				<url-pattern>/</url-pattern>
			</servlet-mapping>
		</web-app>
	- Spring boot MVC - No need to configure web.xml or view response 

	spring MVC
	-----------
		Controller
		---------------
		@Controller - class level annotaion
		@RequestMapping/ @GetMapping/ @PutMapping/ @PostMapping/ @DeleteMapping - Method level annotations 
	

		@Controller
		public class UserController { //Controller Bean class

			//Old style
			@RequestMapping(value="/getUsers", method = RequestMethod.GET)
			public ModelAndView findUsers() {
				---
				---
			}

			//New Style
			@GetMapping("/getUsers")
			public ModelAndView findUsers() {// findUsers() is called Handler Method
				---
				---

				return new ModelAndView("view_name", "model_name", model_value); //String, String, Object -- will return view_name.jsp
				//InternalResourceViewResolver - to resolve a view name to actual view by adding a prefix & suffix - which needs to configure.
 
			}

		}
 

		1) DispatcherServlet calls HandllerMapping[RequestMappingHandlerMapping] bean to identify appropriate Controler
		2) HandllerMapping[RequestMappingHandlerMapping] bean returns appropriate Controller which associates the request to DispatcherServlet.
		3) Then DispatcherServlet calls that Controller bean.



	@Controller
	public class EmployeeController {
		@GetMapping("/index")
		public ModelAndView getIndexPage() {
			return new ModelAndView("index");
		}
	}
	
	@GetMapping("/employee/deptno") 
	public ModelAndView getEmployeesByDeptno(int deptno) {
		List<Employee> wmpList = service.findEmpsByDno(deptno);
		return new ModelAndView("show", "employee", empList);
	}


	- In SpringBoot by default InternalResourceViewResolver class is associated for View Resolver bean. It maps the view name to actual view.
	- InternalResourceViewResolver maps actual view by appending prefix & suffix.
		prefix = "/WEB-INF/views/"
		suffix = ".jsp"

		So, "/WEB-INF/views/show.jsp" will be the response for the DispatcherServelt, then DispatcherServelt renders show.jsp & responds.
	
		/WEB-INF/views/*.jsp

	- In SpringBoot prefix & suffix to be set in application.properties

	- Web applications are created to share resources. these resources may be a page/data/functionality.


	Current development scenario - No need to return ModelAndView object, just need to set model data to ModelMap & return view name 
	----------------------------------------------------------------------------------------------------------------------------------
	@GetMapping("/employees")
	public String getEmployees(ModelMap model) { //ModelMap is a type of Map only, instead of ModelMap it can be used Model/ Map**
		List<Employee> employeesList = service.findEmployees();
		model.addAttribute("employees", employeesList); //Model is set to ModelMap
		return "show"; //Returns only view name
	}
	
	**ModelMap extends LinkedHashMap implements Model [Model is from spring]

	Simple Spring MVC(No Spring boot) application development requires :
	------------------------------------------------------------------------
	1) MVC related dependencies to pom.xml
	2) add DispatcherServlet configuration to web.xml
	3) define spring configuration in dispatcher-servlet.xml
	4) deploy war on a server


	Spring boot MVC application development requires :
	-------------------------------------------------------
	1) add spring-boot-starter-web in pom.xml
	2) add server/ prefix/ suffix properties in application.properties
	3) run application

	Create application - starts.spring.io
	-------------------------------------------
	dependencies - 
	----------------
	1) spring-boot-starter-web
	2) //If jsp is a view
		<groupId>org.apache.tomcat.embed</groupId>
		<artifactId>tomcat-embed-jasper</artifactId>

	application.properties
	----------------------------
	server.port=2223
	server.servlet.context-path=/mvc
	spring.mvc.view.prefix=/WEB-INF/views/
	spring.mvc.view.suffix=.jsp

	
	package com.mvc.controller;
	@Controller
	public class HelloController {
		@GetMapping("/hello")
		public String returnWelcomePage() {
			return "welcome";
		}
	}

	create a jsp file in this directory :
	/src/main/webapp/WEB-INF/views/welcome.jsp
			
	welcome.jsp
	---------------
	<h1>Jai Ram G ki</h1>

	
	run & request as http://localhost:2223/mvc/hello


pom.xml
--------------
<dependency>
	<groupId>jstl</groupId>
	<artifactId>jstl</artifactId>
</dependency>

application.properties
---------------------------
server.servlet.context-path=/Train
spring.mvc.view.prefix=/WEB-INF/views
spring.mvc.view.suffix=.jsp


@Repository
public class TrainDaoImpl implements TrainDaoIntf {
	@Autowired
	JdbcTemplate jdbcTemplate;
	
	public Train findTrain(Integer trainno) {
		Map map = jdbcTemplate.queryForMap("select * from train_details where train_no = ?", trainno);
		
		Train train = new Train();
		BigDecimal bd = (BigDecimal)map.get("train_no");
		Integer trno = bd.intValue();
		train.setTrainno(trno);
		train.setSource(map.get("source").toString());
		train.setDestination(map.get("destination").toString());

		//Here RowMapper can be used to map object with POJO automatically.
	}
}

@Controller
public class TrainController {
	@Autowired
	TrainDaoIntf intf;

	@GetMapping("")
	public String {
		return "search";
	}

	@GetMapping("")
	public String searchTrainByNo(@RequestParam Integer trainno, Model model){
		Train train = intf.findTrain(trainno);
		model.addAttribute("train", train);
		retrun "result";
	}
	
	
}

result.jsp
--------------
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%> //EL - expression language/ jstl tag
<table>
	<tr>
		<th>Train#</th>
		<th>Source</th>
		<th>Destinaion</th>
		<th>Dept time</th>
		<th>Arr time</th>
	</tr>
	<tr>
		<td><c:out value="${train.trainno}"/></td>
		<td><c:out value="${train.source}"/></td>
		<td><c:out value="${train.destination}"/></td>
		<td><c:out value="${train.depttime}"/></td>
		<td><c:out value="${train.arrtime}"/></td>
	</tr>

</table>


Data Binding
=================
- By binding a UI form with application object, we achieve data binding.
- With JSP it can be achieved by adding the tag library as 
- WebDataBinder - DispatcherServlet calls WebDataBinder to bind UI controls to bean.

	<%@taglib uri="http://www.springframework.org/tags/form" prefix="form"%>

	<form:form action="xxx" modelAttribute="userData">//form tag - first form is prefix & second one is tag name
											    //add javaBeanObject(userData) with a name in ModelMap of spring

	@Controller
	public class UserController {

		@GetMapping("/userForm")
		public String getUserFormPage(Model model) {
			UserBean userBean = UserBean();
			model.addAttribute("userData", userBean);
			return "user";
		}
	}

On click of Submit button in UI, associated url is handled by the handler method to read the data,
which uses @ModelAttribute to bind method parameter to the model attribute.

Submit form -> @Controller -> 

@Controller
public class UserController {
	@GetMapping("/xxx")
	public String getUserPage() {
		//code
	}

	@PostMapping("/addUser")
	public String addUserDetails (@ModelAttribute UserBean userBean) {
		//code
	}
} 

	
Data Validation
===================
- Javascript validation is done on client side which is not much secure, for this need to validate data on server side.
- To validate data at server side, spring framework has not given any annotations.
- Sun has provided Bean Validation API(in interfaces) to validate data on java bean class with annotation.
- Hibernate has provided its implementation as Hibernate validator API.
- For this need to use dependency - spring-boot-starter-validation.
- WebDataBinder - DispatcherServlet calls WebDataBinder to bind UI controls to bean.

@AssertTrue
private boolean isActive; //Field value must be true

@AssertFalse
private boolean isDeleted; //Field value must be false

@NotEmpty //Can be applied only in String field
String userName; //userName should not be empty. else validation error.

@Size(min=5, max=10) //Can be applied only in String field
String password; 

@NotNull 
Date dob;

@NotNull //can be applied on objects, enum etc.
Gender gender;

@NotEmpty
@Email
String email;

@Min(18)
@Max(21)
Integer age; //@Min, @Max can be used with Integer, int, short, long.

@DecimalMin(15.15)
@DecimalMax(25.25)
Double price; // For decimal(float/ double)

@Past
@Future
Date field; // With date fields

@Pattern(regex="")
String code; // Can be applied on String field only

^ = used to match beginning of the value.
^[A-Z]

$ = used to match end of the value.
[0-9]$

* = 0 or multiple characters.
[a-z]*

+ = 1 or multiple characters.

[a-z]{10} = should be 10 lower case letters.
[a-z]{5,8} = minimum 5 & maximum 8 lower chars.

@Pattern(regex="^[A-Z][a-z]*")
String userName; //first char would be capital & rest of the char should small.

Handling error message
--------------------------
- should be defined in "messages.properties" file(file name must be messages.properties) & put this file in resources directory with application.properties.
- must be followed below convention for mesage :
	constraint.commandname.field=error message

	for e.g.
	---------------
	NotEmpty.userBean.userName=Username is required. //userBean is ModelAttribute name.

	in jsp
	---------------
	<form:errors/> //This tag is used to show the error message at a time or nearby each & every fields.


- BindingResult object stores all the validation errors.
	@PostMapping("/xxx")
	public String doRegister(@Valid @ModelAttribute UserBean userBean, BindingResult result){
		//@ModelAttribute binds method parameter to ModelAttribute
		//@Valid is indicating that the parameter bean is validated
		//This handler method requires BindingResult object to store all the error messages while validate.
		if(result.hasError()){
			return "registration";//Returning same page, error messages will be appended by BindingResult.
		}
		else
		{
			//code
		}
	}


Spring email API 
-------------------
JavaMailSender interface - JavaMailSenderImpl class - with SMTP server
- To send email without attachment - SimpleMailMessage class is used

Example[register-login system]
---------------------------------
If user not registered, system should show error message in the page & redirects to register by entering email.

index.jsp [http://localhost:8080/crm/index]
--------------------------------------------
DispatcherServlet(stops request) 	<-> HandlerMapping
						<-> RegisterController
						<-> ViewResolver
						->  view -> New User? Sign Up -> DS -> RegisterController -> view(register.jsp) -> 	First Name__________
								 Existing User? Sign in									Last Name___________
																					email_______________
																							submit

Submit -> DS -> RegisterController -> EmailService - send success email to user.

Login -> DS -> LoginController -> success.jsp/ error/login.jsp


Customer registration application with spring email, validation & data binding
================================================================================
project name = crm
package = com.crm
dependencies = JDBC API, Spring Web, Validation, Oracle Driver(ojdbc8), Java Mail Sender(spring-boot-starter-mail), org.apache.tomcat.embed(tomcat-embed-jasper) & jstl(jstl) 1.2

src/main/webapp/WEB-INF/views

com.crm.controller
com.crm.model
com.crm.service
com.crm.dao
com.crm.dao.impl
com.crm.service

@Repository
public class RegisterDaoImpl implements IRegisterDao {
	@Autowired
	JdbcTemplate jdbcTemplate;
	
	public boolean saveCustomer(CustomerBean customerBean){
		int count = jdbcTemplate.queryForObject("Select count(*) from customer_tab where email=?", Integer.class, customerBean.getEmail());
		if(count==1){
			return false;
		}
		else{
			jdbcTemplate.update("insert into customer_tab(email, first_name, last_name) values(?,?,?)", );
			return true;
		}
	}
	
}

@Component
public class RegisterController {
	@Autowired
	EmailService emailService;

	@Autowired
	IRegisterDao registerDao;

	@GetMaipping("/index")
	public String getIndexPage() {
		return "index";
	}

	@GetMapping("/register") 
	public String getRegisterPage(Model model){
		CustomerBean customerBean = new CustomerBean();
		model.addAttribute("custBean", customerBean); //adding customerBean to model for Data Binding with UI
		return "register";
	}

	@PostMapping("/save")
	public String registerCustomer(@Valid @ModelAttribute("custBean") CustomerBean customerBean, BindingResult result, Model model, HttpServletRequest request) {
		if(result.hasErrors()) {
			return "register";
		}
		else{
			boolean flag = registerDao.saveCustomer(customerBean);
			if(flag==false){
				model.addAttribute("message", "Customer already registerd. try another Id");
				return "register";
			}
			else{
				//send email to customer for register
				String name = customerBean.getFirstName()+" "+customerBean.getLastName();
				emailService.sendEmailToCustomer(customerBean.getEmail(), name);
				return "registrationSuccess";
			}
		}
	}
}

@Service
public class EmailService {
	@Autowired
	JavaMailSender mailSender;

	public void sendEmailToCustomer(String mailId, String name){
		SimpleMailMessage mailMessage = new SimpleMailMessage();
		mailMessage.setTo(mailId);
		mailMessage.setSubject("");
		mailMessage.setText(name+"");
		mailMessage.send();
	}
}

package com.crm.model;
public class CustomerBean {
	@NotEmpty
	private String firstName;
	
	@NotEmpty
	private String lastName;
	
	@NotEmpty
	@Email
	String email;

	@Pattern(regexp="^[a-z][a-z0-9#@!]*")
	@Size(min=8, max=15)
	private String password;

	@Min(21)
	@Max(35)
	@NotNull
	private Integer age;

	@NotNull
	private Gender gender;

	@NotNull
	private String country;

	@NotNull
	@Past
	@DateTimeFormat(pattern="yyyy-MM-dd")
	private Date dateOfBirth;

	@NotNull
	private Long contactNumber;

	private Map<String, String> countries = new HashMap<>();
	
	//assign countries in constructor
	public CustomerBean() {
		//put some countries values in map.
	}
	
}

public enum Gender {
	MALE, FEMALE, OTHER
}

@Controller
public class LoginController {
	@Autowired
	ILoginDao dao;
	
	@GetMapping("/login")
	public String getLoginPage(Model model){
		model.addAttribute("loginBean", new LoginBean());
		return "login";
	}
	
	@PostMapping("/userLogin")
	public String userLogin(@ModelAttribute LoginBean loginBean, Model model) {
		boolean flag = dao.loginCheck(loginBean.getEmail(), loginBean.getPassword());
		if(flag==false){
			model.addAttribute("msg", "Bad Credential");
			return "login";
		}
		else{
			return "loginSuccess";
		}
	}
}

@Repository
public class LoginDaoImpl implements ILoginDao {
	@Autowired
	JdbcTemplate jdbcTemplate;

	public boolean loginCheck(String email, String password){
		
	}
}

public class LoginBean {
	private String email;
	private String password;

	//Getter-Setter
}


index.jsp
-----------
New User? <a href="register">Sign UP</a><br>
Existing User? <a href="login">Sign In</a>

register.jsp
---------------
<%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>
<%@taglib uri="http://www.springframework.org/tags/form" prefix="form"%>

<c:if test="${message ne null}">
	<c:out value="${message}"/>
</c:if>


<form:form action="save" method="post" modelAttribute="custBean"> //save is a url
<table>
	<tr>
		<td>FirtName</td>
		<td><form:input path="firstName"/></td>
		<td style="color:red"><form:errors path="firstName"/></td>
	</tr>
	
	---
	---
	---
	<tr>
		<td>DOB</td>
		<td><form:input type="date" path="dateOfBirth"/></td>
		<td style="color:red"><form:errors path="dateOfBirth"/></td>
	</tr>

	<tr>
		<td>Country</td>
		<td>
			<form:select path="country"/> 
				<form:option value="">--select country--</form:option>
				<form:options items="${cutBean.countries}"/> //for data loop
			</form:select>
		</td>
	</tr>
</table>
</form:form>

registrationSuccess.jsp
----------------------------
You have registered successfully! Now go to index page.
<a href="index">Home</a>

login.jsp
---------------
<c:if test=${}>
<form:form action="userLogin" method="post" modelAttribute="loginBean">
	<table>
		Email
		Password
		Submit
	</table>
</form:form>

messages.properties
-------------------------------
#error messages

NotEmpty.custBean.firstName=First Name is required

NotEmpty.custBean.lastName=Last Name is required

NotEmpty.custBean.email=Email is required
Email.custBean.email=Invalid email

Min.custBean.age=Age must be >= 21
Max.custBean.age=Age must be <= 25


application.properties
--------------------------
server.port=2221
server.servlet.context-path=/CRM
spring.mvc.view.prefix=/WEB-INF/views/
spring.mvc.view.suffix=.jsp

#DataSource properties
spring.datasource.driver-class-name=oracle.jdbc.driver.OracleDriver
spring.datasource.url=jdbc:oracle:thin:@localhost:1521:xe
spring.datasource.username=xxx
spring.datasource.password=xxx

#Email SMTP properties
spring.mail.host=smtp.gmail.com
spring.mail.port=587
spring.mail.username=
spring.mail.password=
spring.mail.properties.mail.smtp.starttls.enable=true
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.ssl.trust=smtp.gmail.com

#go to email settings, privacy & enable less secure app access



Spring Boot Data JPA
==========================
- There are a various ways to connect spring application with database

	# Spring data access module provides for CRUD operations(Spring's aim to eliminate Dao implementation class):
		1) spring-jdbc-api 
		2) spring-orm-api

	Why Spring Data?
	-------------------
	- Spring's aim to eliminate Dao implementation class from user point of view. Only need to create a Dao interface.
	- Only need to declare methods(additional operations if required) in Dao interface.
	- All the declared methods implementation is provided by spring data at runtime.

	Spring Data Project[Main Project]
	--------------------------------------
		# Spring Data Commons [PagingAndSortingRepository + CrudRepository interfaces] [core-project] - Contains common behaviours 
		- JPA [] [sub-project]
		- MongoDb [MongoRepository] [sub-project]
		- Redis [sub-project]
		- Couchbase [sub-project]
		- Casandra [sub-project]

	* PagingAndSortingRepository extends CrudRepository

		#CrudRepository
		- save(entity)
		- flush() - To sync with database
		- deleteById(Id)
		- deleteAll()
		- findById(Id)
		- findAll()
		- existById(Id)

		#PagingAndSortingRepository
		- findAll(Sort sort)
		- findAll(Pageable pageable)

	* JPA(Java Persistence API specification from Sun to map java classes with table & JPQL) [JpaRepository interface]
		- JPQL(Java Persistence Query Language)
		** JpaRepository extends PagingAndSortingRepository ( -> CrudRepository)

		- By default Spring boot uses Hibernate as a JPA Provider.


	- One application may have many Entity; For each Entity should have separate Repository would be there to perform CRUD operations.


	For e.g
	-------------
	@Entity
	public class Stock {
		
	}

	@Repository
	public interface StockRepository extends JpaRepository<Stock, Entity_Id_data_type>{}
	
	@Entity
	public class Warehouse{
		
	}

	@Repository
	public interface WarehouseRepository extends JpaRepository<Warehouse, Integer>{}


	- Need to create separate Repository for each Entity.
	

class material link-> [https://groups.google.com/forum/#!forum/test_examples]

 
Need to consider for SPRING DATA JPA project
-----------------------------------------------
1) Enable JpaRepository [<jpa:repositories>]
2) configure DataSource bean
3) configure LocalContainerEntityManagerFactory bean
4) configure HibernateJpaVendorAdaptor
5) add multiple dependencies to pom.xml


Need to consider for SPRING BOOT DATA JPA project
---------------------------------------------------
1) add spring-boot-starter-data-jpa
2) create Repository interfaces


Query creation Approaches
-----------------------------
1) Query creation by method name
2) Query creation using @Query
3) query creation using @NamedQuery

# Query creation by method name keywords:
	1) findBy
	2) getBy
	3) readBy
	4) queryBy	

	keyword+DataMember+<Operator>

@Entity
@Data
public class Passenger {
	@Id
	private Integer passengerId;
	private String firstName;
	private String lastName;
	private String email;
	private String contactNumber;
	private Integer seatNumber;
}

@Repository
public interface PassangerRepository extends JpaRepository<Passenger, Integer>{
	//JpaRepository<Entity_class_name, data_type_of_Id_field>

	Passenger findByEmail(String email);
	
	List<Passenger> findByFirstName(String firstName);

	List<Passenger> findByEmailOrContactNumber(String email, Long contactNumber);

	List<Passenger> findBySeatBetween(Integer seat1, Integer seat2);

	List<Passenger> findByLastNameOrderByFirstNameAsc(String lastName);

	List<Passenger> findBySeatNumberLt(Integer seatNumber);	

	List<Passenger> findBySeatNumberGreaterThanEqual(Integer seatNumber);

}
	
save()
saveAndFlush() // For both purposes- save or update
deleteById()
deleteAll()
existById()
findById()
findAll()


Can we use @OneToMany relation in Entity to fetch all data in Spring Boot Data JPA?
Can we create Join related query by method?

# Query creation using @Query
---------------------------------
JPQL(Java Persistence Query Language)/ SQL

select * from emp;// SQL QUERY
select e from Employee e; // JPQL QUERY - works on Entity classes

select empno, sal from emp;//SQL 
select e.empNumber, e.salary from Employee e;//JPQL

select * from emp where deptno=?//SQL
select e from Employee e where e.deptNumber=?1//JPQL [?1...?n where 1 to n is index parameter]

@Repository
public interface Employee extends JpaRepository<Employee, Integer>{
	
	//JPQL - with index parameters(?1)
	@Query("select e from Employee e where e.deptNumber=?1")
	List<Employee> getEmpsByDeptno(Integer deptno); //any method name can be used here

	//JPQL - with named parameters(:name) - more readable
	@Query("select e from Employee e where e.deptNumber=:deptno and e.empSal=:sal")
	List<Employee> getEmployees(Integer dno, double sal);
	or
	List<Employee> getEmployee(@Param("deptno") Integer dno, @Param("sal") Double sal);


	//JPQL
	@Query("select e.empNumber, e.empSal from Employee e") //Partial select query - returns List<Object[]>, array will contain empNum & sal
	List<Object[]> readEmployees();


	//SQL
	@Query(value="select * from emp where sal>?", nativeQuery=true)//need to pass second argument as "nativeQuery=true" in case of SQL query
	List<Employee> findEmpBySalary(double sal);
	
}

Query creation using @NamedQuery
------------------------------------
- Write/define Named Query in Entity class & add the same name in method in multiple repository to execute the query.
- JPQL query

@Entity
@NamedQuery(name="Employee.fetchEmpsByDeptno", query="select e from Employee e where e.deptNumber=?1")
//naming convention for name - Entity_class_name.method_name
@Table(name="emp")
public class Employee {
	---
	---
	---
}

@Repository
public interface EmployeeRepository extends JpaRepository<Employee, Integer>{
	List<Employee> fetchEmpsByDeptno(Integer dno);
}

Multiple named query - JPQL
------------------------------
@Entity
@NamedQueries({
	@NamedQuery(name="xxx", query="yyy"),
	@NamedQuery(name="xxxx", query="yyy")
})
@Table(name="emp")
public class Employee {
	---
	---
	---
}


Query creation using @NamedNativeQuery
----------------------------------------
- Write/define Named Native Query in Entity class & add the same name in method in multiple repository to execute the query.
- SQL query

@Entity
@NamedNativeQuery(name="Employee.fetchEmpsByDeptno", query="select * from emp where deptno=?1")
//naming convention for name - Entity_class_name.method_name
@Table(name="emp")
public class Employee {
	---
	---
	---
}

@Repository
public interface EmployeeRepository extends JpaRepository<Employee, Integer>{
	List<Employee> fetchEmpsByDeptno(Integer dno);
}

Multiple named native query - SQL Queries
--------------------------------------------
@Entity
@NamedNativeQueries({
	@NamedNativeQuery(name="nxxx", query="yyy"),
	@NamedNativeQuery(name="nxxxx", query="yyy")
})
@Table(name="emp")
public class Employee {
	---
	---
	---
}

e.g.
=========
STS -> starter project 

group: com.sathyatech
artifact : data.jpa1

dependencies : oracle driver, Spring Data JPA[spring-boot-starter-data-jpa], lombok

package com.jpa.entity
@Entity
@Data
//@NamedNativeQuery(name="Passenger.fetchPassangers", query="select * from passenger where first_name like '%k%' ")//SQL 
@NamedQuery(name="Passenger.fetchPassangers", query="select p from passenger where p.firstName like '%k%' ")//JPQL 
public class Passenger {
	@Id
	private Integer passengerId; //It will map with the column as "passanger_id"[capital letter in middle treats as _(underscore)] Or if it is different then use @Column(name="pid")
	
	@Column(length=15)//by default String mapping field in DB creates varchar2(255)
	private String firstName; //first_name

	@Column(length=15)
	private String lastName;

	@Column(length=25)
	private String email;

	private Long contactNumber;

	private Integer seatNo;
	
}

package com.jpa.repository
@Repository
public interface PassengerRepository extends JpaRepository<Passenger, Integer> {
	
	Passenger findByEmail(String email);
	
	@Query("select p from Passenger p where p.seatNo>=:from and p.seatNo<=:to")
	List<Passenger> readPassengerBetween(@Param("from") Integer from, @Param("to") Integer to);// @Param binds method parameter to named parameter of query
	
	List<Passenger> fetchPassangers();//from @NamedNativeQuery from Entity class
}

package com.jpa.runner
@Component
public class MyRunner extends CommandLineRunner {

	@Autowired
	PassengerRepository repo;

	@Override
	public void run(String... args) throws Exception {
		

		//Insert record
		Passenger p = new Passenger();
		p.setPassengerId(101);
		p.setFirstName("Ganesh");
		p.setLastName("Gupta");
		p.setEmail("ganesh@gmm.com");
		p.setContactNumber(111111111223L);
		p.setSeatNo(27);

		repo.save(p);

		

		//Find By Id
		//Optional object : Its like a container object - to avoid null pointer exception

		Optional<Passenger> opt = repo.findById(101);//return Optional
		Passenger p = opt.get();//
	
		System.out.println("Passenger Id = "+p.getPassengerId());
		System.out.println("Passenger Name = "+p.getFirstName()+" "+p.getLastName());

		
		//Find All
		List<Passenger> passengerList = repo.findAll();//Returns iterable object
		
		passengerList.forEach(p->{
			System.out.println("Passenger Id = "+p.getPassengerId());
			System.out.println("Passenger Name = "+p.getFirstName()+" "+p.getLastName());
			sysout("-----------");
		});

		//Custom JPA method query
		Passenger p = repo.findByEmail("meena@gmail.com");
			System.out.println("Passenger Id = "+p.getPassengerId());
			System.out.println("Passenger Name = "+p.getFirstName()+" "+p.getLastName());

		
		//Custom method by @NamedQuery
		List<Passenger> passengerList = repo. fetchPassangers();
		
		passengerList.forEach(p->{
			System.out.println("Passenger Id = "+p.getPassengerId());
			System.out.println("Passenger Name = "+p.getFirstName()+" "+p.getLastName());
			sysout("-----------");
		});	
		
	}

}

application.properties
------------------------
spring.datasource.driver-class-name=oracle.jdbc.driver.OracleDriver
spring.datasource.url=jdbc:oracle:thin:@localhost:1521:xe
spring.datasource.username=system
spring.datasource.password=y=tiger

spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=update ['create' = creates & drop - used for testing purpose | 'update' = does not drop, if table not exist in DB it creates]


run app


Sorting
--------------
Sort sort = Sort.by("firstName").ascending();//By default ascending
List<Passenger> passengerList = repo.findAll(sort);

Sort sort = Sort.by("firstName").ascending().and(Sort.by("seatNo").descending());
List<Passenger> passengerList = repo.findAll(sort);

Pagination
--------------
- get data by page wise - it requires Pageable interface & PageRequest class.

Pageable pageable = PageRequest.of(0,10,Sort.by("seatNo"));//first_page, number_of_records_per_page, sort_obj

Page<Passenger> page = repo.findAll(pageable);

page.getContent()
hasNext()
hasPrevious()
getNumber()
isFirst()
isLast()

MVC app for pagination
----------------------------
Jpa-Pagination

pom.xml - web, data-jpa, tomcat-embed-jasper, jstl, mysql-connector-java

package com.pagination.entity
@Entity
@Table(name="emp")
public class Employee {
	@Id
	private Integer empno;
	
	private String ename;
}

package com.pagination.repository
@Repository
public interface EmployeeRepository extends JpaRepository<Employee, Integer> {}

package com.pagination.service
public interface IEmployeeService {
	Page<Employee> findEmployees(int pageIndex);
}

package com.pagination.service.impl
public class EmployeeServiceImpl implements IEmployeeService {

	@Autowired
	EmployeeRepository repository;
	@Override
	public Page<Employee> findEmployees(int pageIndex) {
		Pageable pageable = PageRequest.of(pageIndex, 3, Sort.by("sal"));
		return repository.findAll(pageable);
	}

}

package com.pagination.controller
@Controller
public class EmployeeController {
	@Autowired 
	IEmployeeService service;

	@GetEmployee(value="/emps") //emps?pageIndex=1
	public String getEmployee(@RequestParam(defaultValue="0") int pageIndex, ModelMap modelMap) {

		//@RequestParam binds request parameters with method parameters
		//ModelMap object is accessible to the JSP page.

		Page<Employee> page = service.findEmployees(pageIndex);
		List<Employee> empList = page.getContent();
		modelMap.addAttribute("employees", empList);
		modelMap.addAttribute("next", page.hasNext()); //if(true) currentpage+1
		modelMap.addAttribute("back", page.hasPrevious()); //if(true) currentpage-1
		modelMap.addAttribute("currentPage", getNumber());
		
		return "ShowEmployee";

	}
}

src/main/webapp/WEB-INF/views/ShowEmployees.jsp
ShowEmployees.jsp

<%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>
<table>
	<header>
		<tr>
			<th>E. No</th>
			<th>E. Name</th>
			<th>Sal</th>
			<th>Dept No</th>
		</tr>
	</header>
	<c:if test="${!empty employees}">
		<c:forEach items="${employees}" var="e">
			<tr>		
			<td><c:out value="${e.empno}"/></td>
			<td><c:out value="${e.ename}"/></td>
			<td><c:out value="${e.sal}"/></td>
			<td><c:out value="${e.deptno}"/></td>
			</tr>
		</c:forEach>
	</c:if>
<table>

<c:if test="${back}">
	<a href="emps?pageIndex=${currentPage-1}">Back</a>
</c:if>

<c:if test="${next}">
	<a href="emps?pageIndex=${currentPage+1}">Next</a>
</c:if>

application.properties
-------------------------
server.servlet.context-path=/Pagination
spring.mvc.view.prefix=/WEB-INF/views/
spring.mvc.view.suffix=.jsp

spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/test
spring.datasource.username=root
spring.datasource.password=root

spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=update ['create' = creates & drop - used for testing purpose | 'update' = does not drop, if table not exist in DB it creates]

mysql> use db_name;
mysql> use test;
mysql> select * from emp; //empno|ename|sal|deptno


Relationships(Associations)
=================================
- To perform crud operations on multiple Entity classes at a time, we need association.

1) one-to-many
2) many-to-one
3) many-to-many
4) one-to-one

1) OneToMany
-----------------
Customer(1) -> Order(M)

Parent(1) -> Chile(M)

CUSTOMER [CUSTID(PK), CUSTNAME]
ORDERS [ORDERID(PK), ITEMNAME, ORDERDATE, CUSTID_FK(FK)]

Cascade=ALL ["Which operations to be cascaded" - "All means Save, Update, Delete" operations are cascaded on associated tables] 

@Entity
public class Customer {
	@Id
	private Integer custid;
	private String custname;
	
	@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER) //To be cascaded to the joined child table with all operations as save, update, delete

	@JoinColumn(name="custid_fk", referencedColumnName="custid") //takes [foreign key column - Foreign key exist in child table] and [referencedColumnName - primary key column in parent table] - referencedColumnName property is optional.
	private Set<Order> orders;
	
}

@Entity
@Table(name="ORDERS")
public class Order {
	@Id
	private Integer orderid;
	private LocalDate orderdate;
	private String itemname;
}


@OneToMany
@JoinColumn

Set<Order> orders = new HashSet<Order>();
orders.add(order1);
orders.add(order2);
orders.add(order3);

customer.setOrder(orders);

customerRepository.save(customer);

@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)//second parameter is optional
@JoinColumn(name="foriegn_key", referencedColumnName="primary_key_refered_by_foriegn_key")//second parameter is optional


e.g onetomay app 
------------------------


##Watch 2 days vidoes on desktop & update this notes.



ManyToOne relationship
---------------------------
spring starter project ->
name = manytoone
package = mto
dependencies = spring data JPA, lombok, oracle driver

*Lombok need to activate in IDE first time : 
1)Go to c:/users/admin/.m2/repository/org/projectlombok/lombok/1.18.12/lombok-1.18.12.jar
2)double click on lombok-1.18.12.jar
3)in the IDE selector window select your IDE, if IDE is not listed then click on specify location of installed IDE and select IDE.exe
4)click on install/update
5)quit it & restart IDE.

maven local repository = c:/users/admin/.m2/repository/

com.mto
com.mto.entity
com.mto.repository
com.mto.runner


com.mto.entity
@Entity
@Data //@Getter + @Setter + @RequiredArgsConstroctor + @ToString + @EqualsAndHashCode
@NoArgsConstructor
public class Customer {
	@Id
	private Integer custId;
	
	@Column(length=15)
	private String custName;
}

@Entity
@Data
@NoArgsConstructor
@Table(name="ORDERS")
public class Order {
	@Id
	private Integer id;

	private String itemName;

	private LocalDate orderDate;

	//Many Orders for One Customer - At the time of sav
	@ManyToOne(casecade=CasecadeType.ALL)//Here default fetch type is eager, not lazy. But in OneToMany default is lazy loading
	@JoinColumn(name="CUSTID_PK")//foriegn key column
	private Customer customer;//Reference variable to parent Entity class.
}

@Repository
public interface CustomerRepository extends JpaRepository<Customer, Integer> {}

@Repository
public interface OrderRepository extends JpaRepository<Order, Integer> {}

@Component
public class MyRunner implements CommandLineRunner throws Exception{
	@Autowired
	OrderRepository orderRepo;

	@Override
	public void run(String... args){

		Customer customer = new Customer();
		customer.setId(101);
		customer.setCustName("A");

		Order order1 = new Order();
		order1.setId(11101);
		order1.setItemName("Laptop");

		Order order2 = new Order();
		order2.setId(11102);
		order2.setItemName("Bag");


		//In Many to One, in 'many' Entity only need to set 'one' Entity
		order1.setCustomer(customer);
		order2.setCustomer(customer);

		orderRepo.save(order1);//first customer Entity will be inserted then order entity will be saved.
		orderRepo.save(order2);//Only the order entity will be inserted not customer at this time.

		//To check eager loading in Many to one
		//select order, it should fetch customer also.
		//If fetch type is set to lazy, then only order will be selected not customer.
		Order ord = orderRepo.findById(11101).get(); 

		//When an order is deleted, customer will also be deleted if one order is associated with the customer. If the customer is having another order associated then delete operation will throw Exception[integrity constraint violation - child record found]. To resolve this change the cascade type NOT to All
		orderRepo.deleteById(11101);

	}
}

application.properties
-------------------------

Many-To-Many
--------------
Category(1) - Item(M)
Item(1) - Category(M)

Book(1) - Author(M)
Author(1) - Books(M)

**ManyToMany relationship needs a join table with two foreign key columns.

Book(BookId, BookName, authorid_fk)
Author(AuthorId, AuthorName, bookid_fk)
BOOKS_AUTHORS(bookid_fk, authorid_fk) - Join Table

@JoinTable has to provide these three properties :
	1) name
	2) joinColumns
	3) inverseJoinColumns

	Only persist operation can be cascaded.


package com.mtm.Entity
@Entity
public class Book {
	@Id
	private Integer bookid;
	private String bookname;
	
	@ManyToMany(casecade=CasecadeType.ALL)
	@JoinTable(name="BOOKS_AUTHORS", joinColumns=@JoinColumn(name="BOOKID_FK"), inverseJoinColumns=@JoinColumn(name="AUTHORID_FK"))
	private Set<Author> authors;

}
package com.mtm.Entity
@Entity
public class Author {
	@Id
	private Integer authorid;
	private String authorname;

	@ManyToMany(cascade=CascadeType.ALL)
	@JoinTable(name="BOOKS_AUTHORS", joinColumns=@JoinColumn(name="AUTHORID_FK"), inverseJoinColumns=@JoinColumn(name="BOOK_FK"))
	private List<Book> books;
}

package com.mtm.repository
@Repository
public interface AuthorRepository extends JpaRepository<Autor, Integer> {}

@Repository
public interface BookRepository extends JpaRepository<Book, Integer> {}


package com.mtm.runner;
@Component
public class MyRunner implements CommandLineRunner {
	@Autowired
	BookRepository bookRepo;

	@Autowired
	AuthorRepository authorRepo;

	@Transactional // at method level or transaction level - 
	@Override
	public void run(String... args) throws Exception {
		/*

		Book b1 = new Book();
		b1.setBookId(1);
		b1.setBookName("Java");
		
		Author a1 = new Author();
		a1.setAuthorid(91);
		a1.setAuthorname("A");

		Author a2 = new Author();
		a2.setAuthorid(92);
		a2.setAuthorname("B");

		List<Author> authorsList = new ArrayList<>();
		authorsList.add(a1);
		authorsList.add(a2);

		b1.setAuthors(authorsList);

		Book b2 = new Book();
		b2.setBookId(2);
		b2.setBookName("Spring");

		Book b3 = new Book();
		b3.setBookId(3);
		b3.setBookName("Oracle");

		List<Book> booksList = new ArrayList<>();
		booksList.add(b2);
		booksList.add(b3);

		a2.setBooks(booksList);

		bookRepo.save(b1);

		*/

		/**
		* Add a new author to a book
		*
		*	1) Create a Author
		*	2) get book object from db
		*	3) get authorList from book object
		*	4) add newly created author to authorList
		* 	5) Use @Transactional or make a change in Entity to fetchType = EAGER.
		*/
		Author new_author = new Author();
		new_author.setAuthorid(93);
		new_author.setAuthorname("C");

		Book b = bookRepo.findById(1).get();
		List<Author> authList = b.getAuthors();
		authList.add(new_author);

		/**
		* Suppose need to remove an author from the specific book - use authList.remove(new_author);
		*
		*/
		

		//authorRepo.save(a2);//after inserting b1, uncomment this & comment above line & execute
		
	}
}

application.properties
----------------------------

SQL
----------------------------
select * from book;
select * from author;
select * from books_authors;

OneToOne
-----------------
person-passport
person-dl
desktop-employee

OneToOne relationship can be provided by two ways :
1) one to one with Foreign Key - id in the parent & child table will be different

	**Foreign key should not contain duplicate or null in child table

	PERSON (PERSONID, PERSONNAME)
	PASSPORT (PASSPORTID, EXPDATE, PERSONID_FK) // PERSONID_FK should not contain duplicate or null

2) one to one with Primary Key - id in the parent & child table will be same
	
	PERSON (PERSONID, PERSONNAME)
	PASSPORT (PASSPORTID, EXPDATE, PERSONID_FK)

@ManyToOne
@JoinColumn(name="fk", unique=true)

** Set parent entity reference to the child class.

e.g.
----------
@Entity
public class Person {
	@Id
	private Integer personid;

	private String personname;
}

@Entity
public class Passport { //Child class

	@Id
	private Integer passportNo;

	private LocalDate expDate;

	@ManyToOne(cascade=CascadeType.ALL)
	@JoiColumn(name="PERSONID_FK", unique=true) //One to one Foreign key
	private Person person;//parent reference in child
}

@Repository
public interface PassportRepository extends JpaRepository<Passport, Integer>{}
@Repository
public interface PersonRepository extends JpaRepository<Person, Integer>{}

package com.oto.runner;
@Component
public class MyRunner implements CommandLineRunner {
	
	@Autowired
	PassportRepository repo;

	@Override
	public void run(String... args) throws Exception {
		Person person = new Person();
		person.setPersonId(101);
		person.setPersonName("ANIL");

		/*Passport passport = new Passport();
		passport.setPassportNo(11231);
		passport.setExpDate(LocalDate.of(2025, 12, 31));
		passport.setPerson(person); //** Set parent entity reference to the child class.

		repo.save(passport);*/

		//To check one to one - create a new passport & assign the same peron - 101 - should throw unique constraint violation exception.
		Passport new_passport = new Passport();
		new_passport.setPassportNo(11233);
		new_passport.setExpDate(LocalDate.of(2024, 12, 31));
		new_passport.setPerson(person);

		repo.save(new_passport);
		
	}

}

By making a primary key as a foreign key in child entity, will make One to One relationship

OneToOne with primary key
--------------------------
- Without creating foreign key field in child table, it can be maintained OneToOne relationship.
 
@GenericGenerator - to define generator strategy for Id
@Id
@GeneratedValue - to assign GenericGenrator

STS - file - new project - "onetoonepk"
dependencies - Lombok, Oracle Driver, Spring Data Jpa

package com.oto.entity
@Entity
public class Person {
	@Id
	private Integer personId;

	private String personName;
}

@Entity
public class Passport { //Child class - make primary key as foreign key - copy id of the parent entity to child entity.

	@GenericGenerator(name = "g1", strategy = "foreign", parameters= @Parameter(name = "property", value = "person")) 
	//Foreign is a hibernate gennerator - to use this generator in generic manner use @GenericGenerator. "foreign" strategey copy id from parent property.
	//In @Parameter(name = "property", value = "person") //person is a parent property

	@Id
	@GeneratedValue(generator="g1")
	private Integer passportNo;

	private LocalDate expDate;

	@OneToOne(cascade=CascadeType.ALL)
	//In this case no JoinColumn required
	@PrimaryKeyJoinColumn //It tells that primary key is used as a foreign key
	private Person person;//parent reference in child
}

@Repository
public interface PassportRepository extends JpaRepository<Passport, Integer>{}
@Repository
public interface PersonRepository extends JpaRepository<Person, Integer>{}

package com.oto.runner;
@Component
public class MyRunner implements CommandLineRunner {
	
	@Autowired
	PassportRepository repo;

	@Override
	public void run(String... args) throws Exception {
		Person person = new Person();
		person.setPersonId(101);
		person.setPersonName("ANIL");

		Passport passport = new Passport();
		//passport.setPassportNo(11231); // Not required now - person_no will be copied to the passportNo - So it will be 101 as person_id
		passport.setExpDate(LocalDate.of(2025, 12, 31));
		passport.setPerson(person); //** Set parent entity reference to the child class.

		repo.save(passport); //passport & person will be saved but id of the both column would be same now.
 
		
	}

}

Joining - To read data from multiple entities
--------------------------------------------------
* To read the data from multiple tables in a single query - Join is used
For e.g. to fetch data from Customer & Order entities together at once.

A customer has many orders 
CUSTOMER(custid, custname, ...)
ORDER(orderid, itemname, orderdate, ...)

We can use JPQL(by using entity properties)/ SQL(by using table feilds) 

Inner Join (Default join) - fetch only matching data
Left Outer Join - more data from left
right Outer Join
full join


Inner Join - SQL
---------------------
select c.custname, o.itemname, o.orderdate from customer c join order o where c.custid=o.custid_fk;

Inner Join - JPQL
---------------------
select c.custname, o.itemname, o.orderdate from Customer c join c.orders o

//parent entity class having collection reference variable of child - here c.orders represents collection reference variable.

In ToMany
-------------
select c.customerName, o.itemName, o.orderDate from Customer c join c.orders o; //Inner Join


In ManyToOne
-------------
select c.customerName, o.itemName, o.orderDate from Order o join o.customer c; //Inner Join

In OneToMany project
------------------------
package com.otm.repository
@Repository
public interface CustomerRepository extends JpaRepository<Customer, Integer> {
	
	@Query("select c.custName, o.iteName, o.orderDate from Customer c inner join c.order o "); //JPQL | inner join fetches only matching data | it will return List<Object[]>
	List<Objetc[]> readData();

	or with left outer join
	@Query("select c.custName, o.iteName, o.orderDate from Customer c left outer join c.order o "); //JPQL | left Outer join fetches more data from left table.
	List<Objetc[]> readLeftOuterData();

	or with SQL join
	@Query(value = "", nativeQuery = true)
	List<Objetc[]> readSQLData();
	
}

public class MyRunner implements CommandLineRunner{

	@Autowired
	private CustomerRepository custRepo;

	public void run(String... args){
		List<Object[]> objList = custRepo.readData();
		objList.forEach(obj -> {
			System.out.println(obj[0]+" , "+obj[1]+" , "+obj[2]); //customerName, itemName, orderDate
		});
	}
}

1+N selects problem in Hibernate/ JPQL
=========================================
Suppose there are three customer on Customer table - for each customer multiple orders are there in Order table. 

select all the customers & read all of their orders.
1) one select statement will be executed to select all three customers.
2) then for each customers separate select statements will be executed to fetch their associated orders 
- So total number of select statement will be 1+3
- It decreases application performance

Solution for 1+N is @Fetch(FetchMode.SUBSELECT) with private Set<Order> orders in Customer Entity class;

select * from customer;
select * from orders;

for e.g. of 1+N issue in MyRunner.java of oneToMany app

	List<Customer> custList = custRepo.findAll();
	
	//It will fetch first list of all customers with 1 query
	//Then for all customers will fetch associated orders list by n queries.

@Fetch(FetchMode.SUBSELECT) // Two query will be executed(1+1 query)
@Fetch(FetchMode.JOIN) // Single query will be executed with join query of customer & order(1 query)
@Fetch(FetchMode.SELECT) // DEFAULT Fetch Mode - 1+N queries


In Customer Entity
@Entity
public class Customer {
	---
	---
	---
	@OneToMany(cascade=CasecadeType.All, fetch=FetchType.EAGER)
	@JoinColumn(name="CUSTID_FK")
	@Fetch(FetchMode.SUBSELECT) //FetchMode.JOIN uses single query with outer join select all the customer & their associated Orders
	private Set<Order> orders;

}


Bi-directional
-------------------
Entities : Customer, Order

In One to Many :
- Customer has associated orders with 1:M association

- When perform any operation on Customer like save/update/delete then, its associated collection will also be saved/updated/deleted(will be cascaded save/update/delete on associated orders)


In Many to One :
- Order Entity


If I want to perform operations on Customer should be performed same on Orders also, If I want to perform operations on Orders should be performed same on Customer also So, For this we need to provide both annotations - OneToMany & ManyToOne on both Entity classes. This situation combindly called OneToMany Bi-directional.


Customer {
	@OneToMany(mappedBy="customer") //mappedBy should be a field in target Entity, which makes this relation as bi-directional.
	//@OneToMany(casecade= CascadeType.ALL, fetch=FetchType.EAGER, mappedBy="customer")//Can be written like this.
	Set<Order> orders;
}

Order {
	@ManyToOne
	Customer customer;
}

If we use mappedBy then @JoinColumn can't be provided. @JoinColumn is provided on ManyToOne association.

@OneToMany(casecade= CascadeType.ALL, fetch=FetchType.EAGER, mappedBy="customer")


Procedure/ Function in Spring Data Jpa
===========================================
A procedure may have n input & output parameters.

create procedure - calculatebonus in Oracle DB
input : empno
output: empname & bonus

create or replace procedure calculatebonus(eno in number, name out varchar2, bonus number out)--parameter_name parameter_mode parameter_data_type
is
	p number(9,2); 
begin
	select ename into name from emp where empno=eno;
	select sal into p from emp where empno=eno;

	if p<=5000 then
		bonus:= p*0.10;
	else
		bonus:=p*0.20;
	end if;
end;
/

save it as test1

compile test1
SQL> @test1
procedure created.

Procedure with Spring Data Jpa : 
------------------------------------
- If you want to call Stored procedure, need to use @NamedStoredProcedureQueries in Entity class
Spring Tool Suits - File - new - Spring starter project 
name - procedure
package - com.example
groupId - com.sathya
artifactId - procedure
dependencies - Spring Data JPA, Oracle Drive, Lombok

package com.example.entity
@Entity
@Data
@NoArgsConstructor
@NamedStoredProcedureQuery(name="readBonus", procedureName="calculatebonus", parameters={
	@StoredProcedureParameter(mode=ParameterMode.IN, name = "eno", type=Integer.class),
	@StoredProcedureParameter(mode=ParameterMode.OUT, name = "empname", type=String.class),
	@StoredProcedureParameter(mode=ParameterMode.OUT, name = "bonus", type=Double.class),
})
public class Emp {
	@Id
	private Integer empno;
	private String ename;
	private Double sal;
	private Integer deptno;
}
package com.example.repository
@Repository
public interface EmpRepository extends JpaRepository<Emp, Integer> {
	//Stored Procedure returns result in Map<String, Object>
	@Transactional //This method execution must be within a single Transaction
	@Procedure(name="readBonus")
	Map<String, Object> findBonus(Integer eno);
}
package com.example.runner
@Component
public class MyRunner implements CommandLineRunner {

	@Autowired
	EmpRepository empRepo;

	@Override
	public void run(String... args) throws Exception {
		Map<String, Object> output = empRepo.findBonus(7654);

		
		sysout("Employee name = "+output.get("name"));
		sysout("Employee bonus = "+output.get("bonus").toString);//number from DB is returned in java as BigDecimal
	}
}
application.properties
-------------------------
#add datasource properties
spring.datasource.driver-class-name=
spring.datasource.url=
spring.datasource.username=
spring.datasource.password=
spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=update
 
 
Security - MVC Application(CRUD) - Employee Management System(EMS)
=====================================================================
index page
-------------
add employee - new page to enter employee details(addemployee.jsp - submit - db - return to index page & show success message)

list employees - new page(employyeList.jsp - list all employees with edit & delete with each row)

STS - new - Spring Starter Project 

name : ems
group : com.sathyatech
artifact : ems
package : com.ems
dependencies : Spring Data JPA, Spring Web, MySQL Driver, Validation, 
	<dependency>
		<g>org.apache.tomcat.embed</groupId>
		<a>tomcat-embed-jsper</artifactId>
	</dependency>
	<dependency>
		<g>jstl</groupId>
		<a>jstl</artifactId>
		<version>1.2</version>
	</dependency>

next - finish

view directory - src/main/webapp/WEB-INF/views
index.jsp
-------------
<c:if test="${message ne null}">
	<c:out value="${message}">
</c:if>
<hr>
<a href="addEmployee">add employee</a>
<a href="listEmployees">list employees</a>

<a href="logoutMe">Log out</a>


addEmployee.jsp
--------------------------
<%@taglib uri="http://www.springframework.org/tags/form" prefix="form"%>
<form:form action="saveEmployee" method="post" modelAttribute="empModel">
	<table>
		<tr>
			<td>
				empno
			</td>
			<td>
				<form:input path="empno"/>
			</td>
		</tr>
		<tr>
			<td>
				empname
			</td>
			<td>
				<form:input path="empname"/>
			</td>
		</tr>
		---
		---
	</table>
</form:form>


employeesList.jsp
---------------------
<a href="logoutMe">Log out</a>

<a href="addEmployee">Add more Employee</a>

<table>
	<tr>
		<th>emp no</th>
		<th>emp name</th>
		<th>sal</th>
		<th>dept</th>
		<th>actions</th>
	</tr>

	<c:if test="${!empty empModelList}">
	<c:forEach items="${empModelList}" var="emp">
	<tr>
		<td> <c:out value="${emp.empno}"/> </td>
		<td> <c:out value="${emp.empname}"/> </td>
		<td> <c:out value="${emp.sal}"/> </td>
		<td> <c:out value="${emp.deptno}"/> </td>

		<td>
			<a href="editEmployee?id=${emp.empno}"><img src="imgs/edit_image.jpg" width="40">Edit</a> // image location - src/main/resources/static/imgs
			<a href="deleteEmployee?id=${emp.empno}"><img src="imgs/del_image.jpg" width="40">Delete</a> 
		</td>
	</tr>
	</c:forEach>
	</c:if>
	

</table>


editEmployee.jsp
---------------------
<form:form action="updateEmployee" method="post" modelAttribute="emodel">
	<table>
		<tr>
			<td>empno</td><td><form:input path="empno" readonly="true"/></td>
		</tr>

		---
		---
		---
	</table>
</form:form>


logout.jsp
---------------
<h3>You r successfully logged out.</h3>
<a href="index">Home</a>


package com.ems.Entity;
@Entity
@Table(name="emp")
public class Employee {
	@Id
	private Integer empno;

	private String ename;
	private Double sal;
	private Integer deptno;

}

package com.ems.repository;
@Repository
public interface EmployeeRepository extends JpaRepository<Employee, Integer> {

}

package com.ems.bean; //to map bean data with UI
public class EmployeeBean {
	private Integer empno;
	private String enmae;
	private Double sal;
	private Integer deptno;
	
	//Setters/ Getters

}

package com.ems.controller
@Controller
public class EmployeeController {
	@Autowired
	EmployeeRepository repository;

	@GetMapping("/index")
	public String getIndexPage(){
		return "index";
	}

	//Handle logout redirect after logout to show logout message.
	@GetMapping("/loggedOut")
	public String userLogout() {
		return "logout";
	}

	@GetMapping("/addEmployee")
	public String getEmployeePage(Model model){
		EmployeeBean empModel = new EmployeeBean();
		model.addAttribute("empModel",empModel);
		return "addEmployee";
	}

	@PostMapping("/saveEmployee")
	public String saveEmployee(@ModelAttribute("empModel") EmployeeBean empModel, Model model){
		Employee e = new Employee();
		BeanUtils.copyProperties(empModel, e);//(source, target)- copy from source to target
		boolean flag = repository.existById(e.getEmpno());
		if(flag==true){
			model.addAttribute("message","Employee with given empno already exist.");
		}
		esle{
			repository.save(e);
			model.addAttribute("message","Employee added successfully.");
		}

		return "index";
	
	}

	@GetMapping("/listEmployees")
	public String listEmployees(Model model){
		List<Employee> empList = repository.findAll();
		List<EmployeeBean> empModelList = new ArrayList<>();

		empList.forEach(e->{
			EmployeeBean emodel = new EmployeeBean();
			BeanUtils.copyProperties(e, emodel);
			emplModelList.add(emodel);
		});	
		
		model.addAttribute("empModelList", empModelList);
		return "employeesList";
	}

	@GetMapping("/editEmployee")
	public String editEmployeePage(@RequestParam("id") int empno, Model model) {
		Employee e = repository.findById(empno).get();
		EmployeeBean emodel = new EmployeeBean();
		BeanUtils.copyProperties(e, emodel);
		model.addAttribute("emodel", emodel);
		return "editEmployee";
	}

	@PostMapping("/updateEmployee")
	public String updateEmployee(@ModelAttribute("emodel") EmployeeBean emodel){
		Employee e = new Employee();
		BeanUtils.copyProperties(emodel, e);
		repository.saveAndFlush(e); //Behaves in two ways - either to save or to update.
		return "redirect:listEmployee"; //"redirect:" - prefix indicates to redirect to the associated url.
	}

	@GetMapping("/deleteEmployee")
	public String deleteEmployee(@RequestParam("id") int empno) {
		repository.deleteById(empno);
		return "redirect:listEmployees";
	}
	
}

application.properties
---------------------------
server.port=2121
server.servlet.context-path=/Ems
spring.mvc.view.prefix=/WEB-INF/views/
spring.mvc.view.prefix=.jsp

spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=
spring.datasource.user=
spring.datasource.password=

spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=update

run - http://localhost:2121/Ems/index


Spring Security
---------------------
Security is the combination of Authentication+Authorisation.

Authentication = Verifying user credentials - primarily to verify(mandatory).
Authorisation = permission.

Every Authenticated user are not Authorised user.

An web application consist multiple urls, some url are public but some are accessible to particular group of users.
To protect the urls from unauthorised users, need to provide security.

In web application development, need to define security in Web Filter classes - filters to be defined for authenticate/ authorise/ session management/ logout etc., then need to map these to web.xml.

In Spring security, all the Filter classes are defined already, need to just use them - given a Spring Bean class - FilterChainProxy & DeligatingFilterProxy classes. Need to add DeligatingFilterProxy to web.xml & it will contact to FilterChainProxy class to perform security. Once the security checks done, request is forwarded to DispatcherServlet to execute the controller & return model.

A filter consists of Pre & Post execution blocks.

Request ---> DeligatingFilterProxy ---calls---> FilterChainProxy class ---calls---->Group of Filter classes--->request_forword_to_spring_mvc.

- Need to configure DeligatingFilterProxy in web.xml

- Once user is authenticated, request is forwarded from Spring Security to Spring MVC.

- In order to check the user credential & roles, AuthenticationManager object is required. AuthenticationManager object is obtained in Configuration class.

- Configuration class is mandatory which is done by extending SpringSecurityConfigurer class.

- In not a boot app then use the following dependencies : 

	1) spring-security-core
	2) spring-security-web
	3) spring-security-config

- In case of boot app then use spring-boot-starter-security dependency & then no need to configure anything in web.xml. But need to extend WebSecurityConfigurerAdaptor class in the Configuration class.



@Configuration
@EnableWebSecurity
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {
	@Override
	public void configure(HttpSecurity http) {
		- Which requests to be authenticated?
		- Whether to support form-based or Http Basic authentication?
		- Which role of usres can access which urls?
		- restrict multiple sessions at a time?
		- logout feature?
	}

	@Autowired
	public void configureGlobal(AuthenticationManagerBuilder builder) {
		- AuthenticationManagerBuilder is a helper class to build AuthenticationManager object.
		- AuthenticationManagerBuilder object stores users with roles & it can be initialised with In-memory or Database authentication model.
		- security filters uses AuthenticationManager object in authentication process.
	}
}

Security Implementation - On EMS App
----------------------------------------
In EMS app, implement security on users with role admin can delete an Employee. All remain functions can be accessed by any user.

1) Add dependency - spring-boot-starter-security

2) create security configuration class

package com.ems.security
@Configuration
@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

	@Autowired
	BCrypt	PasswordEncoder encoder; //from springframework.security

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		//Method chain 
		http.authorizeRequests()
		.antMatchers("/delete**") //requests starts with delete followed by anything
		.hasAnyRole("ADMIN")
		.anyRequest().permitAll()
		.and()
		//.httpBasic()//Basic authentication model - for spring based login prompt 
		.formLogin()//Form based authentication model - for spring based form login page
		//If role is different for the user(Authorisation failed) then it says Whitelable error page
		//instead of Whitelable default error page, I want my own error page
		.exceptionHandling().accessDeniedPage("/WEB-INF/views/accessDenied.jsp")//In case of exception in authorisation, it will show our jsp page.
		.and()
		.csrf()
		.disable();
	}

	@Autowired //To autowire method parameter
	public void configureGlobal(AuthenticationManagerBuilder builder) throws Exception {
		builder.inMemoryAuthentication()
		.withUser("Ritik").password(encoder.encode("123456")).roles("ADMIN")
		.and()
		.withUser("Ankit").password(encoder.encode("ankit@123")).roles("LEAD");
	}

	@Bean
	public BCryptPasswordEncoder bcrypt() {
		return new BCryptPasswordEncoder();
	}
}


accessDenied.jsp
--------------------
<h2 style="border:2px solid yellow; width: 700px;">
	You are unauthorised to access!
</h2>


Security from USER-DB & restrict user session with SSL
----------------------------------------------------------
1) Tables : USERS(username, password, enabled(0/1)), --0=disabled|1=enabled  | Parent Table
	AUTHORITIES(authority, username) --username=foreign_key | Child Table

	create table users(username varchar(15), password varchar(130), enabled tinyint, primary key(username));
	create table authorities(authority varchar(25), username varchar(15) references users(username));

2) Add JDBC dependency - spring-boot-starter-jdbc

package com.ems.runner
@Component
public class MyRunner implements CommandLineRunner {

	/**
	*	After executing this once, disable @Component - One time execution for user insertion in DB
	*/ 

	@Autowired
	JdbcTemplate jdbcTemplate;

	@Override
	public void run(String... args) throws Exception {
		
		BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();
		
		String pwd1 = encoder.encode("anshu@1211");//Password to be encrypted
		String pwd2 = encoder.encode("ram@n181");//Password to be encrypted
		String pwd3 = encoder.encode("bhuvi_108");//Password to be encrypted

		//insert three users with encrypted password
		jdbcTemplate.update("insert into users values(?,?,?)", "anshu", pwd1, 0);
		jdbcTemplate.update("insert into users values(?,?,?)", "rama", pwd2, 1);
		jdbcTemplate.update("insert into users values(?,?,?)", "bhuvi", pwd3, 1);

		jdbcTemplate.update("insert into authorities values(?,?)", "ROLE_ADMIN", "anshu");
		jdbcTemplate.update("insert into authorities values(?,?)", "ROLE_ADMIN", "bhuvi");
		jdbcTemplate.update("insert into authorities values(?,?)", "ROLE_LEAD", "rama");
		
	}
}


package com.ems.security
@Configuration
@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

	@Autowired
	BCrypt	PasswordEncoder encoder; //from springframework.security

	@Autowired
	@DataSource dataSource; // To get users from DB

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		//Method chain 
		http.authorizeRequests()
		.antMatchers("/delete**") //requests starts with delete followed by anything
		.hasAnyRole("ADMIN")
		.anyRequest().permitAll()
		.and()
		//.httpBasic()//Basic authentication model - for spring based login prompt 
		.formLogin()//Form based authentication model - for spring based form login page
		//If role is different for the user(Authorisation failed) then it says Whitelable error page
		//instead of Whitelable default error page, I want my own error page
		.exceptionHandling().accessDeniedPage("/WEB-INF/views/accessDenied.jsp")//In case of exception in authorisation, it will show our jsp page.
		.and()
		.csrf()
		.disable();

		//Restrict user to login from multiple browsers
		http.sessionManagement().maximumSessions(1);

		//logout - To invalidate the session
		http.logout().logoutUrl("logoutMe").logoutSuccessUrl("/loggedOut").permitAll();
		//logout() - will invalid/ close the session
		//logoutUrl("logoutMe") - logout request url
		//logoutSuccessUrl("/loggedOut") - after log out request need to redirect with this url.
		//permitAll() - To allow "/loggedOut" url for all.

		//SSL - Application has to serve all the pages on secured channel(SSL).
		http.requiredChannel().anyRequest().requiresSecure(); //To specify particular request use antMatchers("/request"...) instead of anyRequest().
	}

	@Autowired //To autowire method parameter
	public void configureGlobal(AuthenticationManagerBuilder builder) throws Exception {
		/*
		builder.inMemoryAuthentication()
		.withUser("Ritik").password(encoder.encode("123456")).roles("ADMIN")
		.and()
		.withUser("Ankit").password(encoder.encode("ankit@123")).roles("LEAD");
		*/

		builder.jdbcAuthentication()
		.dataSource(dataSource)
		.usersByUsernameQuery("select username, password, enable from users where username=?")
		.authoritiesByUsernameQuery("select username, authority from authorities where username = ?")
		.passwordEncoder(encoder);
	}

	@Bean
	public BCryptPasswordEncoder bcrypt() {
		return new BCryptPasswordEncoder();
	}
}

https channel
----------------
- To send some/all pages between client & server on secured channel

client -------https(with encryption)------->server

- A password protected certificate with public-private key pair is required. 
- From server public key will be published to client, server decrypts data with private key.
- browser decrypts data with public.

- certificate is created by trusted CA(Certificate Authorities) like Verisign, B2B, enTrust, trustCenter, etc.
- CA(Certificate Authorities) creates security certificates.

- self signed certificate is used for testing - from JDK, keytool application is prvided, which is used to create self signed certificate
- this self signed certificate is installed in server.
- With command prompt of JDK, self sign certificate is created. 

To generate Self Signed Certificate
-----------------------------------------
1) open command prompt
2) $ keytool -genkeypair -alias sathya -keyalg RSA -keystore D:\keystore.jks -validity 30

	provide password & all the asked informations & remember those.

//keyalg= key algorithm
//keystore = to provide generated filename & location
//.jks = java key store
//validity = 30 days

3) put keystore.jks file in src/main/resources.

4) application.properties
-----------------------------
server.ssl.key-password=spring
server.ssl.key-alias=sathya
server.ssl.key-store=classpath:keystore.jks
server.ssl.key-store-type=JKS
 

5) Run app

6) 	http://localhost:2121/Ems/index - will show Bad Request message.
	https://localhost:2121/Ems/index - OK


Page Level security
-----------------------
- According to user role have to show/ hide content of the page.
- Delete link in the Employee List page, should be shown only for the admin role user.
- It will be imposed via jsp.
1) add a dependency in pom.xml - spring-security-taglibs
2) In employeeList.jsp
	<%@taglib uri="http://www.springframework.org/security/tags" prefix="security"%>


	<td>
		<a href="editEmployee?id=${emp.empno}"><img src="imgs/edit_image.jpg" width="40">Edit</a> // image location - src/main/resources/static/imgs
		
		<security:authorize access="hasRole('ROLE_ADMIN')">
			<a href="deleteEmployee?id=${emp.empno}"><img src="imgs/del_image.jpg" width="40">Delete</a> 
		</security:authorize>
	</td>

Difference between Web application & Web service
========================================================

	- Web application share pages while web services shares data/ functionalities.
	- Web application shares directly to the end user while web services shares to technologies/ applications
	- Web services can be easily developed & maintained and lightweight.


1) Interoperable communication 
-------------------------------
consumer(any language) -----------> Provider [Webservice] (any language)

To create webservices, two specifications are there :
	1) SOAP(Simple Object Access Protocol) - Uses xml to exchange data between consumer & provider.
	2) REST(Representational State Transfer) - Lightweight protocol to exchange data between consumer & provider. 

	For Rest, Sun Microsystem released a specification called JAX-RS. And different implementations has been provided like - Jersey, CXF, resteasy, axis2 etc. We use either sun provided JAX-RS or Spring REST Api for creating REST Web services. JAX-RS and Spring REST Api are two different ways.

2) Provide Service - to whome
------------------------------------
In order to provide services to direct end user, we create web application.
Web application provides pages to serve end user.
while
In order to provide services to other application i.e not direct end user, we create web services.
Web service provides data to other application.


3) Terminology
-----------------
Webservices are created to share/expose the resources[data/functionality] to other consumer applications.
url - each resource is identified with an url. 
resource - what data/functionality, api wants to provide.

for e.g. - http://www.infy.com/employee/72319 = accesses/reads the details of a particular employee.
http://www.citi.com/card/validate/19892737280 = functionality to validate a card 


Web services
-----------------
	1) SOAP - Follows W3c Web Consortium
		- WSDL(Web Services Description Language), Supports XML format, USSD registry, Complicated.
		- Sun provided JAX-WS specifications
		
	2) RESTful - Follows REST Architecture. [Sun provided JAX-RS & Spring REST specifications are used]

		- To create a web service(Service provider)
		- To access a web service(Service consumer)

		- JAX-RS specification implementations :
			Jersey, RESTEasy, Axis2, CXF


		REpresentational State Transfer :
			- Everything is treated as resource(Data/ functionalities). No web pages.
			- Every resource is identified by a unique URI(Uniform Resource Identifier).
				URI - Within server is treated as URI 
				URL - outside server is treated as URL & it is associated with a port. 
			- Returned data can be represented in JSON, XML or HTML.

			- Representational - MIME Types - JSON, XML or HTML
			- State Transfer - When a client make a request to an URI with a http method, client is asking for current data or it can be changed/transferred to other state like update/ delete. 		
			for e.g. - http://www.infy.com/employee/allen - To identify the resource - client may want to get/read data about 'allen' or may want to change the data related to 'allen'.
			- current data exist in server, client wants to read/change this data state by updating it or deleting it.
			- resources are manipulated with http methods like - POST, PUT, DELETE
			
			GET - To Read a resource
			POST - To Create a resource
			PUT - To Update a resource
			DELETE - To Delete/ Discard a resource

			Stateless - Communication between Consumer & Service Provider is stateless - Means service provider(Web Service) does not remember any state of client. In every request a consumer has to send always required information.

			- In MVC or REST - Servlet Dispatcher is the Front Controller in both. 
			But for REST, No View Resolver & view resolver handler classes are available.

			- In Spring Boot, spring-boot-starter-web dependency is used for both Spring MVC and REST applications.


Spring MVC flow
---------------------
Browser(client) <---> Dispatcher Servlet <---> Handler Mapping <---> Controller[Service/ DAO/ DTO / DB] <---> View Resolver <---> Actual View.



Spring Rest with Spring Boot
---------------------------------
In Spring Rest, need to create RestController classes which returns data/ resource with representation(JSON, XML Or HTML).

Application(client) <---> DS <---> HM <---> RestController <---> Service/ DAO/ DTO / DB <---> Returns Data with Representation(JSON/XML/HTML).

Here, no view!, It directly Returns Data with Representation(JSON/XML/HTML) in ResponseBody.

Stereo Type Annotations :
---------------------------
 - Earlier(before spring 4.2) to make a class for REST, we used to use @Controller[class level] + @ResponseBody[method level]

	@Controller - Controller class	

 - From spring 4.2 instead of using two annotations for REST (@Controller & @ReponseBody), has to use single annotation at class level - @RestController.

	@RestController

 - java object to be serialized(java Object to JSON/XML format)/ deserialzed(JSON/XML to Java Object) - jackson-databind api dependency - included in spring-boot-starter-web dependency.

 - By default Response MIME Type is JSON.

 - End Points/ Rest End Points = service URI

	@RestController
	public class ProductRestController  {

		@GetMapping("/products")
		public List<Product> fetchProducts() { //Handler method
			//code
		}
		@PostMapping("/product/add")
		public String addNewProduct(@RequestBody Product product) { 
			//Client sends data in JSON with RequestBody - to convert this JSON to java object, @RequestBody is used. [Deserialize JSON/XML request body 			//to java object]
			//@ResponseBody serialize Java Object to JSON/XML.

						

			//Code
			
		}
		//Define an URI to get Product details based on Id
		@GetMapping("/product/{id}")
		public Product fetchProductById(@PathVariable("id") Integer pid) {
			
			//{-} - PathVariable are included within the {}. multiple path variables can be added in an URI
			//To inject/bind path variable in method parameter need to use, @PathVariable("path_variable_name")
			/Restful webservices can accept the data from client in two ways 1) from RequestBody & 2) from Request URL.
			//Sensitive data should be sent in RequestBody only.

			//Code
		}

		//QueryParameter/RequestParameter with ?key=value & MatrixVariable
		@DeleteMapping("/product/delete")
		public String deleteProductById(@RequestParam Integer pid) {
			//@RequestParam("parameter_name") - parameter_name and 'pid' is same then optional else need to write - @RequestParam("parameter_name")
			
			//Client Request will be as - http://localhost:8080/api/product/delet?pid=10101
		}
		
	}


	@RestController
	public class FlightRestController {
		@GetMapping("/search/{source}/{destination}") 
		public List<Flight> searchFlights(@PathVariable String source, @PathVariable String destination) {
			//code
		}
	}

 
Spring Rest
============
@RestController = @Controller + @ResponseBody
@RequestBody
@PathVariable
@RequestParam
@MatrixVariable

ResponseEntity class
------------------------
	ResponseEntity object = body+status or body+headers+status

Restful Webservice to create endpoints for clients to perform CRUD operations
-----------------------------------------------------------------------------------
RestController 
-----------------
Method		endpoint				description
-------	-----------				--------------
GET  		/allProducts				returns the details of all products
GET		/{id}					returns the details of a specific product
GET		/products/{manufacturer}		returns the details of products of a manufacturer
POST		/product/add				add a new product
PUT		/product/update			updates a new product
DELETE		/product/delete?id=xxx		deletes a product based on query parameter

With the help of Swagger, API list documentation is created.

RestController ---> Service ---> Dao ---> DB.

name : pms-rest
group : 
artifact :
package : com.pms
dependencies : web, data jpa, MySQL Driver, lombok			


package com.pms.entity
@Entity
@Table(name="PRODUCTS")
public class Product {
	@Id
	private Integer productId;
	private String productName;
	private Double price;
	private String manufacturer;
}
			
package com.pms.model //To keep dto classes
public class ProductDTO {
	
	private Integer productId;
	private String productName;
	private Double price;
	private String manufacturer;

}
			
package com.pms.repository
@Repository
public interface ProductRepository extends JpaRepository<Product, Integer> {
	//Query Creation Approach by method
	List<Product> findByManufacturer(String manufacturer);
}

package com.pms.service
public interface IProductService {
	List<ProductDTO> searchAllProducts();
	ProductDTO searchProductById(Integer id);
	List<ProductDTO> searchProductsByManufacturer(String manufacturer);
	String addProduct(ProductDTO productDTO);
	ProductDTO updateProduct(ProductDTO productDTO);
	String deleteProductById(Integer id);
}

//Entity class uses mapping with DB. It may be used with Reflection to obtain So, We do not want to expose data entity class to client so, need to use DTO class here. 

package com.pms.service.impl;
@Service
public class ProductServiceImpl implements IProductService {
	@Autowired
	ProductRepository productRepository;

	@Override
	List<ProductDTO> searchAllProducts() {
		List<Product> productList = productRepository.findAll();
		List<ProductDTO> productDTOList = new ArrayList<>();
		productList.forEach( product -> {
			ProductDTO productDTO = new ProductDTO();
			BeanUtils.copyProperties(product, productDTO);
			productDTOList.add(productDTO);
		});
		return productDTOList;
	}

	@Override
	ProductDTO searchProductById(Integer id) {
		Optional<Product> opt = productRepository.finById(id);
		if(opt.isPresent()){
			Product product = opt.get();
			ProductDTO productDTO = new ProductDTO();
			BeanUtils.copyProperties(product, productDTO);
			return productDTO;
		}
		return null;
	}

	@Override
	List<ProductDTO> searchProductsByManufacturer(String manufacturer) {
		List<Product> productList = productRepository.findByManufacturer(manufacturer);
		List<ProductDTO> productDTOList = new ArrayList();
		productList.forEach(product -> {
			ProductDTO productDTO = new ProductDTO();
			BeanUtils.copyProperties(product, productDTO);
			productDTOList.add(productDTO);
		});
		return productDTOList;
	}

	@Override
	String addProduct(ProductDTO productDTO) {
		Product product = new Product();
		BeanUtils.copyProperties(productDTO, product);
		if(productRepository.existByid(product.getProductId())) {
			return "Product already exist!";
		}
		else {
			productRepository.save(product);
			return "Product is added to DB!";
		}
	}

	@Override
	ProductDTO updateProduct(ProductDTO productDTO) {
		Product product = new Product();
		BeanUtils.copyProperties(productDTO, product);
		if(productRepository.existById(product.getProductId())) {
			productRepository.saveAndFlush(product);
			return productDTO;
		}
		else {
			return null;
		}
	}

	@Override
	String deleteProductById(Integer id) {
		if(productRepository.existById(id)) {
			productRepository.deleteById(id);
			return "Product is deleted successfully!"
		}
		else {
			return "Product does not exist!"
		}
	}
}

package com.pms.controller;
@RestController
public class ProductRestController {
	@Autowired 
	IProductService service;
	
	@GetMapping(value = "/allProducts", produces="application/json")
	public ResponseEntity<List<ProductDTO>> findAllProducts() {
		List<ProductDTO> productDTOList = service.searchAllProducts();
		return new ResponseEntity<List<ProductDTO>>(productDTOList, HttpStatus.OK);

		//ResponseEntity is a Generic type class to return response body with status.
		//OK = 200
	}

	@GetMapping(value="/{id}", produces={"application/json"})
	public ProductDTO findProductById(@PathVariable Integer id) {
		return service.searchProductById(id);
	}

	@GetMapping(value="/products/{manufacturer}", produces="application/json")
	public List<ProductDTO> findProductsByManufacturer(@PathVariable String manufacturer) {
		return service.searchProductsByManufacturer(manufacturer);
	}

	@PostMapping(value="/product/add", consumes="application/json")
	public String addProduct(@RequestBody ProductDTO productDTO) {
		return service.addProduct(productDTO);
	}

	@PutMapping(value="/product/update", consumes="application/json")
	public String updateProduct(@RequestBody ProductDTO productDTO) {
		ProductDTO dto = service.updateProduct(productDTO);
		if(dto==null)
			return "Product does not exist!";
		else
			return "Product updated successfully!"
	}

	@DeleteMapping(value="/product/delete/{id}")
	public String deleteProductById(@PathVariable Integer id) {
		return service.deleteProductById(id);
	}
}

application.properties
--------------------------
server.port=2727
server.servlet.context-path=/pms

spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/test
spring.datasource.username=root
spring.datasource.password=root

spring.jpa.hibernate.ddl-auto=update




PMS Client Application - pms-client
---------------------------------------
package com.client.runner
@Component
public class MyRunner implements CommandLineRunner {

	@Autowired
	RestTemplate restTemplate;
	
	private static String ALL_PRODUCTS 	= "http://localhost:2727/pms/allProducts";
	private static String PRODUCT_BY_ID 	= "http://localhost:2727/pms/{id}";
	private static String ADD_PRODUCT		= "http://localhost:2727/pms/product/add";
	private static String DELETE_PRODUCT	= "http://localhost:2727/pms/product/delete/{id}";

	@Override		
	public void run(String... args) throws Exception {
	
		//restTemplate.exchange(p1,p2,p3,p4) - always returns ResponseEntity
		//p1 - URL
		//p2 - HttpMethod
		//p3 - HttpEntity object/ null
		//p4 - ParameterizedTypeReference object - capturing & storing data in generic types.

		ParameterizedTypeReference<List<ProductDTO>> typeRef = new ParameterizedTypeReference<List<ProductDTO>> (){
			//Anonymous implementation
		};

		ResponseEntity<List<ProductDTO>> re = restTemplate.exchange(ALL_PRODUCTS, HttpMethod.GET, null, typeRef);

		List<ProductDTO> dtoList = re.getBody();
		dtoList.forEach(dto -> {
			sysout("Product Id : "+dto.getProductId());
			sysout("Product Name : "+dto.getProductName());
			sysout("Product price : "+dto.getPrice());
			sysout("Product Manufacturer : "+dto.getManufacturer());
			sysout(-------);
		});

		/**
		* restTemplate.getForObject(p1,p2,p3)
		* p1 = url
		* p2 = response type
		* p3 = values [its a var... args parameter]
		*/

		ProductDTO pdto = restTemplate.getForObjet(PRODUCT_BY_ID, ProductDTO.class, 109)//109 is the id to get product record
		sysout("Product Id : "+pdto.getProductId());
		sysout("Product Name : "+pdto.getProductName());
		sysout("Product price : "+pdto.getPrice());
		sysout("Product Manufacturer : "+pdto.getManufacturer());



		//To Add A Record from client to REST APP.

		HttpHeaders headers = new HttpHeaders();
		headers.setContentType(MediaType.APPLICATION_JSON);
		
		ProductDTO productDto = new ProductDto();
		productDto.setProductId(112);
		productDto.setProductName("TOY");
		productDto.setPrice(749.0);
		productDto.setManufacturer("Nikon");
		
		HttpEntity entity = new HttpEntity(productDto, headers);

		//exchange() is a common method to use any method like GET, POST, PUT etc.
		ResponseEntity<String> res = restTemplate.exchange(ADD_PRODUCT, HttpMethod.POST, entity, String);
	
		sysout(res.getBody());

		//For put use same strategy

		//To Delete a record
		ResponseEntity<String> msg = restTemplate.exchange(DELETE_PRODUCT, HttpMethod.DELETE, null, String.class, 112); //Fourth parameter is a response type.
		sysout(msg.getBody());
		
	}
}

package com.client.model;
public class ProductDTO {
	private Integer productId;
	private String productName;
	private Double price;
	private String manufacturer;

	//Setter/Getters
}

package com.client
@SpringBootApplication
pubic class PmsClientApplication {
	
	public static void main(String[] args) {
		SpringApplication.run(PmsClientApplication.class, args);
	}
	@Bean
	public RestTemplate restTemplate() {
		return new RestTemplate();
	}
}

Caching support
===================
Instead of fetching the data from db every time, it should be fetched data once & store it in chache locally.
It should support for whole application for all client requests.

Chache Provider API
-------------------
JChache
EHChache 
RadisChache
...

Spring provided caching annotation to utilise Cache from chache provider API for store/update/delete/fetch cache data.

Integrate RadisChache(In memory) in REST app
-----------------------------------------------
ReDiS = Remote Dictionary Server - stores data in key-value pair.

1) install & start redis server from redis zip(It also includes redis client to check it is working or not). It will run on port - 6379.
Run Redis client - It will prompt terminal with localhost:6379.
Check it :
$localhost:6379> ping
$localhost:6379> set msg hello [get key value]
ok
$localhost:6379> get msg [get key]
"hello"
$localhost:6379> expire msg 10 [expire key time_in_seconds]
$localhost:6379> del msg [del key]

2) add starter dependencies in Rest App pom.xml - spring-boot-starter-data-redis & spring-boot-starter-cache.
3) use caching annotations of Spring.

	@SpringBootApplication
	@EnableCaching
	@EnableScheduling // For scheduling 
	public class PmsRestApplication {
		
		public static void main(String[] args) {
			SpringApplication.run(PmsRestApplication.class, args);
		}
	
	}

	//Multiple cache regions can be created to store cache specifically module/purpose wise.
	
	methods level annotations :
		@Cacheable(value="cache_name", key="#spring_expression" unless="conditions") - To check/store data in a cache. It first check - if data is not available in cache then it allows the method to run and when method runs it stores data in cache. Next time if data is available in cache then it will not allow the methods to execute DB operation, instead it will return data from cache. 
		@CachePut - To update a data in DB as well as in cache.
		@CacheEvicts - To delete a data in DB as well as in cache.


	@Service
	public class ProductServiceImpl implements IProductService {

		---
		---
		---

		@Cacheable(value = "All_Products_Cache", key = "#root.methodName") //Here #root will become ProductServiceImpl.searchAllProducts [class name]
		@Override
		public List<ProductDTO> searchAllProducts() {
			---
			---
			---
		}

		@Cacheable(value="singleProduct", key = "#id", unless="#result==null") //result is return value of method, if null then do not store in cache
		@Override
		public ProductDTO searchProductById(Integer id) {
			---
			---
			---
		}

		@CachePut(value="Single_Product_Cache", key="#productDTO.productId", unless="#result==null") //To update the data in cache. It will allow to execute method first the update in cache. Here key represents method parameter object's attribute.
		@Override
		public ProductDTO updateProduct(ProductDTO productDTO) {
			---
			---
			---
		}
		
		@CacheEvict(value = "Single_Product_Cache", key="#id")//It will delete the data if exist in cache based on other Cache value attribute. here value is same as @CachePut & key is id which is the parameter of method.
		@Override
		public String deleteProductById(Integer id) {
			---
			---
			---
		}

		//Schedule to delete all data 
		@Scheduled(cron="0 2 20 * * ?") will execute daily 8:02pm
		@CacheEvict(value="All_Product_Cache", allEntries=true)
		public void clearStoreAllProductsCache() {}
	}

	In Redis client console :
	$ localhost:6379> keys*
		1) "All_Products_Cache"::"searchAllProducts"
	$ localhost:6379> del All_Products_Cache::searchAllProducts // will delete this key pair in cache & then fetch data from DB.

	$ localhost:6379> expire All_Products_Cache::searchAllProducts 15 // after 15 seconds data will be erased in Cache.


4) application.properties
--------------------------
spring.cache.type=redis
spring.redis.host=localhost
spring.redis.port=6379
spring.jpa.show-sql=true #To check DB is executing or not.


5) NotSerializableException : implements the ProductDTO with java.io.Serializable - In cache, serializable object is stored.


API Documentation
=======================
1) Manual (Difficult to update after API modification)
2) Tools (Swagger)

Swagger - A tool to generate REST API Documentation.
-------------------------------------------------------
Swagger is a specification & Springfox is the implementation of it.

pom.xml Dependencies - springfox-swagger2 & springfox-swagger-ui

@ApiOperation - To define description of each API at method level
@ApiParam - Description about the method parameter - method parameter level
@ApiResponse - To customise response codes - method level
@ApiResponses - To customise response codes - method level

DocketBean - It will determine which part of the application will be added to the documentation - need to register this object to RestContainer then Swagger will take help of it to generate documentation.

- The documentation can be accessed with /swagger-ui.html.

package com.pms.controller;
@RestController
public class ProductRestController {
	@Autowired 
	IProductService service;
	
	@ApiOperation("Returns the details of all products")
	@ApiResponses({
		@ApiResponse(code=200, message="Fetched the products successfully!")//code, customised message for response
		@ApiResponse(code=404, message="Request URL is wrong!")
	})
	@GetMapping(value = "/allProducts", produces="application/json")
	public ResponseEntity<List<ProductDTO>> findAllProducts() {
		List<ProductDTO> productDTOList = service.searchAllProducts();
		return new ResponseEntity<List<ProductDTO>>(productDTOList, HttpStatus.OK);

		//ResponseEntity is a Generic type class to return response body with status.
		//OK = 200
	}

	@ApiOperation("Returns the details of a specific product")
	@GetMapping(value="/product/{id}", produces={"application/json"})
	public ProductDTO findProductById(@PathVariable Integer id) {
		return service.searchProductById(id);
	}

	@ApiOperation("Returns the details of all products based on manufacturer")
	@GetMapping(value="/products/{manufacturer}", produces="application/json")
	public List<ProductDTO> findProductsByManufacturer(@PathVariable String manufacturer) {
		return service.searchProductsByManufacturer(manufacturer);
	}

	@ApiOperation("Adds a new product")
	@PostMapping(value="/product/add", consumes="application/json")
	public String addProduct(@ApiParam("A product details in JSON format") @RequestBody ProductDTO productDTO) {
		return service.addProduct(productDTO);
	}

	@ApiOperation("Updates an existing product")
	@PutMapping(value="/product/update", consumes="application/json")
	public String updateProduct(@ApiParam("A product details in JSON format") @RequestBody ProductDTO productDTO) {
		ProductDTO dto = service.updateProduct(productDTO);
		if(dto==null)
			return "Product does not exist!";
		else
			return "Product updated successfully!"
	}

	@ApiParam("Deletes a product by Id") 
	@DeleteMapping(value="/product/delete/{id}")
	public String deleteProductById(@PathVariable Integer id) {
		return service.deleteProductById(id);
	}
}

@SpringBootApplication
@EnableCaching
@EnableScheduling // For scheduling 
@EnableSwagger2
public class PmsRestApplication {
		
	public static void main(String[] args) {
		SpringApplication.run(PmsRestApplication.class, args);
	}

	@Bean // To register object returned by the method to the spring container.
	public Docket docket() {
		Docket d = new Docket(DocumentationType.SWAGGER_2);
		d.select().apis(RequestHandlerSelectors.basePackage("com.pms"))
			.paths(PathSelectors.any())
			.build()
			.useDefaultResponseMessages(false);//not to show default response messages in swagger.
		return d;
	}
	
}

http://localhost:2727/pms/swagger-ui.html

Swagger also allows developers to test API in browser.


Securing Rest Api
=========================
1) Spring Security
2) Spring Security Oauth2 [Oauth version2]

Oauth(Open authentication) is a specification/ standard/ open authorisation protocole.
Facebook, Google, Twitter, Spring etc has provided its implementations.
Spring implementation has named Spring Security Oauth2.

An application Wants to use services provided by another without asking end user to share the password.
Suppose, I am having an account in a website & the website using other services without asking my password.

  
ESPN.com wants to host/ share something to my facebook timeline without asking my face book password.

or like asking sign in with google/ linkedIn/ facebook etc in quora.com.



Four Rules - Spring Security Oauth2 has defined four rules
-----------------------------------------------------------
1) Resource Owner ---------> like user
2) resource Server ---------> facebook
3) Authorization Server [To grant tokens] --------> facebook [checks weather the user has facebook account or not, this Authorization server is from facebook in this case]
4) client [Another website who wants to access resource] ---------> quora.com [can access the data from facebook resource server with tokens granted by authorization server]


Five ways - Different ways to update access tokens
-----------------------------------------------------
Oauth tokens grant types - to call end points and access to resource.
Grant types are provided to access tokens. 

1) Authorization code grant type - This grant type is used by third party to access authorization token.
2) resource owners credentials grant type - Trusted client from same organisation like facebook mobile app & facebook web, will use this grant type.
3) implicit grant type - It is used by javascript applications to update access token.
4) client credentials grant type - clients who wants to access its own data from resource server.
5) refresh token grant type - One more time to be obtain access token if expired.


We have To secure rest end point with OAUTH2 security.

1) Authorization code grant type 
	- This grant type is used by third party to access authorization token.
	
	flow 
	--------
	Resource Owner(end-user)/ client application in browser like Quora.com
	sign in with facebook ---> redirect resource owner + POST request-------------> Authorization server[asks facebook login page user/pwd]
					<----	Redirects resource owner with authorization code <---- Authorization server

					---> client id + client secret + authorization code -------> Authorization server
					<----	access token + refresh token <------------------------- Authorization server

					---> calls API endpoint with access token ------------------> Resource server
	Resource Owner(end-user)<----receives user's data <--------------------------------- Resource server


	For this Quora.com has to register with facebook authorization server & get access & secret key.


2) resource owners credentials grant type 
	- Trusted client from same organisation like facebook mobile app & facebook web, will use this grant type.

	Resource-owner/end-user(enters user/pwd) like facebook mobile & web --->
		----------> sends post request with user credentials + client id + client secret ----> Authorization server
		<-----------Access token + refresh token <---------------------------------------------Authorization server

		---------> Calls API endpoint with access token ---------------------------------------> Resource server
		---------> receives users data  <------------------------------------------------------- Resource server

 
3) implicit grant type 
	- It is used by javascript applications to update access token.

	diagram same as resource owners credentials grant type but, user login will be done at Authorization server because, javascript can not validate user credential itself. And its generated access token will be of very short duration. And no refresh token will be generated. 


4) client credentials grant type 
	- clients who wants to access its own data from resource server.
	- clients application itself is a resource owner. It has not to go anywhere outside to validate.

	client app ----sends POST request with clientid + secret ------> Authorization server
			<----access token <---------------------------------- Authorization server

			-----> Calls API endpoint with access token ---------> Resource server
			<----- receives Data --------------------------------- Resource server 


5) refresh token grant type 
	- One more time to be obtain access token if expired.


	client app ----sends POST request with refresh token + clientid + client secret ------> Authorization server
			<----access token + refresh token <----------------------------------------- Authorization server

			------> calls API endpoint with access token --------------------------------> Resource server
			<------ receives user's data <------------------------------------------------ Resource server


OAUTH2 integration with Spring Application
===============================================
1) dependencies : spring-security-oauth2[2.3.3], web, devtools(to edit app in run mode | It restarts automatically)

2) Authorization server - by extending a class AuthorizationServerConfigurerAdapter - To configure Authorization Server.
	- Configure with clientId, clientSecret etc.

	- It will verify the end user is valid or not.
	- This server also use AuthenticationManager from Spring Security to manage user details & URI list to be secured with WebSecurityConfigurerAdapter class.

	@EnableAuthorizationServer - Annotation to be enabled

3) Resource Server - @EnableResourceServer [to be created single application for Authentication Server & Resource Server here].

4) @EnableAuthorizationServer & @EnableResourceServer to be used in SpringBootApplication class.


public class UserProfile {
	name,
	email,
	status
}

@RestController
public class RetsResource {
	@GetMapping("/api/users/me") //only client can access it, who is having access token. To secure this endpoint, configure it in WebSecurityCofigurerAdaptor class.
	public ResponseEntity<UserProfile> profile() {
		User user = (User) SecurityContextHolder.getContext().getAuthentication().getPrincipal(); //Authenticates/checks user

		String email = user.getUsername()+"@sathya.com";

		UserProfile profile = new UserProfile();

		profile.setName(user.getUsername());

		profile.setEmail(email);

		if(user.isEnabled()){
			profile.setStatus("ACTIVE");
		}
		else {
			profile.setStatus("INACTIVE");
		}
		return ResponseEntity.ok(profile);
		//return new ResponseEntity<UserProfile>(profile, HttpStatus.OK);
	}
}

@Configuration
@Order(1)
public class SecurityConfig extends WebSecurityConfigurerAdapter {
	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http.requestMatchers()
		.antMatchers("/login", "/auth/authorize")// for this two no security required(It is open), except these all requests are secured.
		 // "/oauth/authorize" & "/oauth/token" is added automatically because oauth2 dependency & these are accessed by POST method.
		.and()
		.authorizeRequests()
		.anyRequest().authenticated()
		.and()
		.formLogin().permitAll(); //Will show inbuilt login form.
	}

	@Override
	protected void configure(AuthenticationManagerBuilder auth) throws Exception {
		auth.inMemoryAuthentication(0
		.withUser("shecker").password(passwordEncoder().encode("123456")).roles("USER");
	} 

	@Bean
	public BCryptPasswordEncoder passwordEncoder() {
		return new BCryptPasswordEncoder();
	}

	@Bean
	@Override
	protected AuthenticationManager authenticationManager() throws Exception {
		return super.authenticationManager();
	}
}

//Authorization server
@Configuration
@EnableAuthorizationServer
public class OAuth2AuthorizationServer extends AuthorizationServerConfigurerAdapter {
	@Autowired
	private BCryptPasswordEncoder passwordEncoder;

	@Autowired
	AuthenticationManager amBean;

	@Override
	public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
		endpoints.authenticationManager(amBean);
	}

	@Override
	public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {
		security.tokenKeyAccess("permitAll()")
		.checkTokenAccess("isAuthenticated()");
	}

	@Override
	public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
		clients.inMemory()
		.withClient("clientapp").secret(passwordEncoder.encode("654321"))
		.authorizedGrantTypes("authorization_code", "refresh_token", "password")
		.scopes("read")
		.redirectUris("https://localhost:5454/test")
		.accessTokenValiditySeconds(100)
		.refreshTokenValiditySeconds(300);
		
	}
}

@SpringBootApplication
@EnableResourceServer
public class 


http://localhost:5656/oauth/authorize?response_type=code&scope=read&client_id=clientapp - It will prompt login page to provide credential Then will be authenticated & redirects to approval page. I will return a code in url.

In Postman :
---------------
POST : http://localhost:5656/oauth/token
params : 
	key			value
	------		----------
	grant_type		authorization_code
	code			XCzgyw[Obtain from previous request]

Authorization : Type :choose "Basic Auth"
Username :
Password : 

send >

Return will be access_toen, token_type, refresh_token, expires_in & scope.

access_toen is required for further request as :

	http:/ocalhost:5656/api/users/me?access_token=<access_toen>



Actuator
=============
dependency in pom.xml

http://localhost:2727/pms/actuator/info - By default enabled
http://localhost:2727/pms/actuator/health - By default enabled

#below services to be enabled in application.properties
http://localhost:2727/pms/actuator/beans - all the beans will be shown
http://localhost:2727/pms/actuator/mappings - will show all mappings/URI from actuator related information (of endpoints/ methods with their details)
http://localhost:2727/pms/actuator/matrics - to show list of all matrics [to show particular metrics details then just paste the matrics name to url like :
	http://localhost:2727/pms/actuator/matrics/jvm.memory.used
	or
	http://localhost:2727/pms/actuator/matrics/jvm.threads.live
]
http://localhost:2727/pms/actuator/threaddump - to show running threads status at a particular moment. 
http://localhost:2727/pms/actuator/caches/{cache_name_from_application.properties} - To show information about cache
http://localhost:2727/pms/actuator/loggers - will show all loggers [if slf4j logger defined, it will also show]
http://localhost:2727/pms/actuator/shutdown - [request from POST method] - to shutdown the application. Need to enable in application.properties file.



application.properties
-------------------------
#actuator properties
management.endpoints.shutdown.enabled=true #To shutdown the app - request must be through POST method.
management.endpoints.web.exposure.include=*	#Bydefault value is none [* = to show all actuator services].
management.endpoints.web.exposure.exclude=beans,caches 	#will not enable beans & caches services of actuator.
management.endpoint.health.show-details=always	#Bydefault value is never [never|always|when-authorised]
info.app.name=Sample Spring Rest App
info.app.description=This is a Spring CRUD application.
info.app.version=1.0


Profiles
==============
We need to move application to Dev - Test - UAT - Prod. 
These all instances mostly not having same configurations like DB, Cache, Logger etc. configuration/ application properties. It may be in Dev MySQl or in UAT it may be Oracle.

So, application properties can be changed accordingly.

application.properties - common properties should be defined here. [default properties] [MANDATORY]
application-dev.properties - properties related to dev instance.
application-test.properties - properties related to test instance.
application-prod.properties - properties related to prod instance.

src/main/resources/

application.properties
------------------------
spring.profiles.active=dev | test | prod

application-dev.properties
-----------------------------
spring.datasource.driver-class-name=mysql driver class
spring.datasource.url=XXXXXXX


application-test.properties
-----------------------------
spring.datasource.driver-class-name=oracle driver class
spring.datasource.url=XXXXXXX


application-prod.properties
-----------------------------
spring.datasource.driver-class-name=postgresql driver class
spring.datasource.url=XXXXXXX


- In a single yaml file, it can be defined multiple profiles
application.yml
-------------------
server:
	port: 6666
	servlet:
		context-path: /example
spring: 
	profiles:
		active: dev
	mvc: 
		view:
			prefix: /WEB-INF/views/
			suffix: .jsp

--- #three dashes(---) defines separation of yml file to provide other profiles by separating three dashes(---).
spring:
	profile: dev
spring:
	datasource:
		driver-class-name: oracle
		url: xxx
		username: xxx
		password: xxx
---
spring:
	profile: test
spring:
	datasource:
		driver-class-name: mysql
		url: xxx
		username: xxx
		password: xxx
---
spring:
	profile: prod
spring:
	datasource:
		driver-class-name: postgressql
		url: xxx
		username: xxx
		password: xxx


- In a single application, properties & yml both files can be added.
- first yml is loaded then properties file.
- If same properties defined in both the files, properties file will override that because it is loaded later than yml.

profiles-app
---------------
dependency - web

package com.profiles.bean;
@Component
public class SampleBean {
	
	@Autowired
	Environment env;

	//@Value("${spring.app.name}")
	//private String appName;

	public String getData() {
		//return appName;
		return env.getProperty("sample.app.name"); //sample.app.name from yml
	}
}

package com.profiles.controller 
@RestController
public class SampleController {

	@Autowired
	SampleBean sampleBean;

	@GetMapping("/data")
	public String showData() {
		return sampleBean.getData();
	}
}

src/main/resources

application.properties
-------------------------
spring.app.name=xyz #this line requires during start the app
spring.profiles.active=dev
server.port=3434


new - others - general file 

application-dev.properties
------------------------------
spring.app.name=Dev Environment Application

application-test.properties
------------------------------
spring.app.name=Test Environment Application

application-prod.properties
------------------------------
spring.app.name=Prod Environment Application

OR

application.yml
----------------
spring:
	profiles:
		active: Test
server:
	port: 3434
---
spring:
	profiles: dev
sample:
	app:
		name: Dev Environment Application
---
spring:
	profiles: Test
sample:
	app:
		name: Test Environment Application
---
spring:
	profiles: Prod
sample:
	app:
		name: Prod Environment Application


start app
---------
http://localhost:3434/data


Microservices
=================
Why
---------
Presentation Layer + Business Layer + Data Access Layer + DB = Monolithic application produces 1 jar/war file
- Downtime = In monolithic application, if a small change happens, need to compile & deploy entire application - It increases downtime of application(not available during deploy).
- Load Balance = In monolithic application, if more requests are coming for a module business set, entire application goes down & maintenance issue occurs. 
- Single Language = Monolithic application developed with a single language only.

Features
-------------
- Microservice is an architectural style.[Initially NETFLIX used this style].
	- Make application functionality independent & small. Communication between applications with HTTP protocols to share the data.
	- individual maintenance/ development/ deployment is possible.
	- Can be scaled up a particular application if large request/ load.[scaling particular service possible.]
	

- REST is also an architectural style.



Scenarios 			Monolithic							Microservices
------------			-------------------						---------------------
Development - 		One Language							each service can be developed in diff language

Testing - 			For any changes, full regression testing is required.	regression testing only for the particular microservice.

packaging - 			single war							each service is a jar/war

scalability - 		entire app is replicated on multiple servers.		scale only a particular service which is having more load.

Minor change - 		Full rebuild & re deployment is required.			Only changed service is rebuild & redeployment.


Develop Microservices :
------------------------------
CallDetails MS [CallDetails-Micro]
Plan MS [Plan-Micro]
Customer MS [Customer-Micro]
Friend MS [Friend-Micro]

Dependencies : Zuul, Eureka, Zipkin(Performance Service), Config Server

1) CallDetails Microservice
-------------------------------
New - project

Name: ms-calldetails
GroupId:com.example
ArtifactId:ms-calldetails
version: 1.1

dependencies : web, Spring Data JPA, MySQL Driver

@SpringBootApplication
public class MsCallDetailsApplication{
	public static void main(String[] args){
		SpringApplication.run(MsCallDetailsApplication.class, args);
	}
}

package com.calldetails.controller;
package com.calldetails.entity;
package com.calldetails.dto;
package com.calldetails.service;
package com.calldetails.service.impl;
package com.calldetails.repository;

package com.calldetails.entity;
@Entity
public class CallDetails {
	@Id
	private Long callId;
	private long calledBy;
	private Long calledTo;

	@Temporal(TemporalType.DATE)
	private Date calledOn;

	private Long durationInSeconds;
}

package com.calldetails.dto;
public class CallDetailsDto {
	
	private Long callId;
	private long calledBy;
	private Long calledTo;
	private Date calledOn;
	private Long durationInSeconds;
}

package com.calldetails.repository;
@Repository
public interface CallDetailsRepository extends JpaRepository<CallDetails, java.lang.Long> {
	List<CallDetails> findByCalledBy(Long phoneNumber);
}

package com.calldetails.service;
public interface ICallDetailsService {
	List<CallDetailsDto> readCallDetails(Long phoneNumber);
}

package com.calldetails.service.impl
@Service
public class CallDetailServiceImpl implements ICallDetailsService {
	@Autowired
	CallDetailsRepository repository;

	@Override
	public List<CallDetailsDto> readCallDetails(Long phoneNumber) {
		List<CallDetails> callDetailsList = repository.findByCalledBy(phoneNumber);

		List<CallDetailsDto> callDetailsDtoList = new ArrayList<>();

		callDetailsList.forEach(callDetails -> {
			CallDetailsDto dto = new CallDetailsDto();
			BeanUtils.copyProperties(callDetails, dto);
			callDetailsDtoList.add(dto);
		});

		return callDetailsDtoList;
	}
}

package com.calldetails.cotroller
@RestController
public class CallDetailsRestController {
	@Autowired
	ICallDetailsService service;

	@GetMapping("/{phoneNumber}")
	public List<CallDetailsDto> getCallDetailsByPhoneNumber(@PathVariable Long phoneNumber) {
		return service.readCallDetails(phoneNumber);
	}
}

application.properties
------------------------
server.port=4141

spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/calldetailsdb
spring.datasource.username=root
spring.datasource.password=root

spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=update

#rootpath
server.servlet.context-path=/calDetailsApi

2) Plan Microservice
------------------------
Name: ms-plan
package: com.plan
dependencies: Spring Data JPA, web, MySQL

com.plan.controller
com.plan.entity
com.plan.dao
com.plan.dto
com.plan.service
com.plan.service.impl

package com.plan;
@SpringBootApplication
public class MsPlansApplication{
	public static void main(String[] args){
		SpringApplication.run(MsCallDetailsApplication.class, args);
	}
}

package com.plan.entity;
@Entity
@Table(name="PLANS")
public class Plan {
	@Id
	@Column(length=15)
	private Strings planId;
	private String splanName;
	private Integer validity;
	private String description;
}

public class PlanDto {
	private Strings planId;
	private String splanName;
	private Integer validity;
	private String description;
}

@Repository
public interface PlanRepository extends JpaRepository<Plan, String> {

}

public interface PlanService {
	public List<PlanDto> getAllPlans();
	public PlanDto getSpecificPlan(String planId);
}

@Service
public class PlanServiceImpl implements PlanService {
	@Autowired
	PlanRepository planRepo;

	@Override
	public List<PlanDto> getAllPlans(){
		List<Plan> planList = planRepo.findAll();
		
		List<PlanDto> planDtoList = new ArrayList<>();

		for(Plan plan: planList){
			PlanDto dto = new PlanDto();
			BeanUtils.copyProperties(plan, dto);
			planDtoList.add(dto);
		}

		return planDtoList;
	}

	@Override
	public PlanDto getSpecificPlan(String planId) {
		Optional<Plan> opt = planRepo.findById(planId);
		Plan plan = opt.get();
		PlanDto = new PlanDto();
		BeanUtils.copyProperties(plan, dto);
		return dto;
	}

}

@RestController
public class PlanRestController {
	@Autowired
	PlanService service;

	@GetMapping("/browsPlans")
	public List<PlanDto> getPlans() {
		return service.getAllPlans();
	}
		
	@GetMapping("/{planId}")
	public PlanDto getSpecificPlan(@PathVariable String planId){
		return service.getSpecificPlan(planId);
	}
}

application.properties
------------------------
server.port=4242

spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/plandb
spring.datasource.username=root
spring.datasource.password=root

spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=update

#rootpath
server.servlet.context-path=/PlanApi


3) Friend Microservice
--------------------------
Name: ms-friend
package: com.friend
dependecies: Spring Data JPA, web, MySQL

@Entity
public class Friend {
	@Id
	@GeneratedValue(strategy=GenerationType.AUTO)
	private Integer id; 
	private Long phoneNumber;
	private Long friendNumber;
}

@Repository
public interface FriendRepository extends JpaRepository<Friend, Integer> {

	@Query(value="select count(*) from friend where phone_no=? and friend_no=?", nativeQuery=true)
	Integer checkFriendContact(Long phoneNumber, Long friendNumber);

	@Query(value="select friend_no from friend where phone_no=?", nativeQuery=true)
	List<Long> findFriendsContactNumbers(Long phoneNumber);

} 

public interface FriendService {
	public String addFriendService(Friend friend);
	List<Long> readFriendsContacts(Long phoneNumber);
}

public class FriendServiceImpl implements FriendService {

	@Autowired
	FriendRepository repository;
	
	@Override
	public String addFriendService(Friend friend) {
		Integer count = repository.checkFriendContact(friend.getPhoneNumber(), friend.getFriendNumber());
		if(count==0) {
			repository.saveAndFlush(friend);
			return "Friend contact is added!";
		}
		else {
			return "Friend contact already exist!"
		}
	}

	@Override
	List<Long> readFriendsContacts(Long phoneNumber) {
		return repository.findFriendsContactNumbers(phoneNumber);
	}
}

@RestController
public class FriendRestController {
	@Autowired
	FriendService service;

	@PostMapping("/addFriend")
	public String addFriend(@RequestBody Friend friend){
		return service.addFriendService(friend);
	}

	@GetMapping("/{phoneNumber}")
	public List<Long> getFriendContacts(@PathVariable Long phoneNumber){
		return service.readFriendsContacts(phoneNumber);
	}
}

application.properties
------------------------
server.port=4343

spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/frienddb
spring.datasource.username=root
spring.datasource.password=root

spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=update

#rootpath
server.servlet.context-path=/FriendApi


Customer Microservice
------------------------
Name: ms-customer

/register - a new customer(phone, username, password, email, planId) 
/login
/view-profile

package com.customer.controller;
package com.customer.entity;
package com.customer.dto;
package com.customer.dao;
package com.customer.repository;
package com.customer.service;
package com.customer.service.impl;

@Entity
public class Customer {
	@Id
	@Column(name="PHONE_NO")
	private Long phoneNumber;

	private String userName;
	private String password;
	private String email
	private String planId;
}

public class CustomerDto {
	private Long phoneNumber;
	private String userName;
	private String email
	private String planId;
	
	private List<Long> friendsContactNumbers;
	private PlanDto currentPlan;
}

public class PlanDto {
	private Strings planId;
	private String splanName;
	private Integer validity;
	private String description;
}

public class RegisterDto {
	private Long phoneNumber;
	private String userName;
	private String password;
	private String email
	private String planId;
}

public class LoginDto {
	private Long phoneNumber;
	private String password;
}

public class CallDetailsDto {

}


@Repository
public interface CustomerRepository extends JpaRepository<Customer, Long> {
	@Query(value="select count(*) from customer where phone_no =? and password=?", nativeQuery=true)
	Integer checkLogin(Long phoneNumber, String password);
}

public interface CustomerService {
	public boolean registerCustomer(RegisterDto, registerDto);
	public boolean loginCustomer(LoginDto, loginDto);
	public CustomerDto readCustomer(Long phoneNumber);
}

@Service
public class CustomerServiceImpl {
	@Autowired
	CustomerRepository repository;

	public boolean registerCustomer(RegisterDto, registerDto) {
		if(repository.existById(registerDto.getPhoneNumber())==false){
			Customer customer = new Customer();
			BeanUtils.copyProperties(registerDto, customer);
			repository.save(customer);
			return true;
		}else{
			return false;
		}
	}
	public boolean loginCustomer(LoginDto, loginDto) {
		if(repository.checkLogin(loginDto.getPhoneNumber(), loginDto.getPassword())==1){
			return true;
		}
		else {
			return false;
		}
	}
	public CustomerDto readCustomer(Long phoneNumber) {
		Customer customer = repository.findById(phoneNumber).get();
		CustomerDto dto = new CustomerDto();
		BeanUtils.copyProperties(customer, dto);
		return dto;
	}
}

@RestController
public class CustomerController {
	
	@Autowired
	CustomerService service;

	@Autowired
	RestTemplate restTemplate;

	private static String PLAN_URL = "http://localhost:4242/PlanApi/{planId}";
	private static String FRIEND_URL = "http://localhost:4343/FriendApi/{phoneNumber}";
	
	@PostMapping("/register")
	public boolean addCustomer(@RequestBody RegisterDto registerDto){
		return service.registerCustomer(registerDto);
	}

	@PostMapping("/login")
	public boolean loginCustomer(@RequestBody LoginDto loginDto) {
		return service.loginCustomer(loginDto);
	}

	@GetMapping("/viewProfile/{phoneNumber}") 
	public CustomerDto showProfile(@PathVariable Long phoneNumber) {
		
		CustomerDto customerDto = service.readCustomer(phoneNumber);
		
		//Calling ms-plan for plan details
		PlanDto planDto = restTemplate.getForObject(PLAN_URL, PlanDto.class, customerDto.getPlanId);//url, response-type, uri-variable	 
		customerDto.setCurrentPlan(planDto);
		
		//Calling ms-friend
		List<Long> friendsContactNumber = restTemplate.getForObject(FRIEND_URL, List.class, phoneNumber);
		customerDto.setFriendsContactNumers(friendsContactNumbers);

		return customerDto;
		
	}
}

@SpringBootApplication
public class MsCustomerApplication {
	psvm(String[] args){
		SpringApplication.run(MsCustomerApplication.class, run);
	}

	@Bean
	public RestTemplate restTemp() {
		return new RestTemplate();
	}
}

application.properties
------------------------
server.port=4444

spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/customerdb
spring.datasource.username=root
spring.datasource.password=root

spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=update

#rootpath
server.servlet.context-path=/CustomerApi


UI: with jsp & mvc
===================
index.jsp
----------
New Customer: SignUp ---> addCustomer.jsp
Existing Customer: SignIn  ---> login.jsp

addCustomer.jsp
-------------------
user name, password, phoneNumber, email, choosePlan dropdown
submit_button --> mvc_controller ---> customer_microservice/register_end_point

login.jsp
----------
phone, password
submit --> mvc_controller ---> customer_microservice/login

success_login ---> home.jsp [customer_dashboard]

home.jsp
---------
dashbord icons for - add friend, view plans, etc...

spring-boot
-----------
name: ui-app
package: com.ui
dependencies: web, validation, jasper, jstl

groupId: org.apache.tomcat.embed & jstl
artifact: tomcat-embed-jasper & jstl

create folder: src/man/webapp/WEB-INF/views

@SpringBootApplication
@Bean
public RestTemplate restTemplate(){
	return new RestTemplate();
}

package com.ui.controller;
@Controller
public class UIController {
	private static String ALLPLANS_URL = "http://localhost:4242/PlanApi/browsPlans";
	private static String REGISTER_URL = "---";
	private static String LOGIN_URL = "---";
	private static String PROFILE_URL = "---";
	private static String CALLDETAILS_URL = "http://localhost:4141/CallDetailsApi/{phoneNumber}";

	@Autowired
	RestTemplate restTemplate;

	@GetMapping("/index")
	public String getIndexPage(){
		return "index";
	}

	private List<PlanDto> getPlans() {
		ParameterizedTypeReference<List<PlanDto>> typeRef = new ParameterizedTypeReference<List<PlanDto>>(){};
		ResponseEntity<List<PlanDto>> re = restTemplate.exchange(ALLPLANS_URL, HttpMethod.GET, null, typeRef);
		List<PlanDto> plansList = re.getBody();
		return planList; 
	}

	@GetMapping("/registerPage")
	public String getRegisterPage(Model model){
		RegisterBean registerBean= new RegisterBean();
		registerBean.setPlanList(getPlans());
		model.addAttribute("registerBean", registerBean);
		return "register";
	}

	@PostMapping("/addCustomer")
	public String addCustomer(@Valid @ModelAttribute RegisterBean registerBean, BindingResult result, Model model) {
		if(result.hasError()){
			//call microservice-planDetails
			registerBean.setPlanList(getPlans());
			model.addAttribute("registerBean", registerBean);
			return "register";
		}

		//call microservice-customer
		boolean flag = restTemplate.postForObject(REGISTER_URL, registerBean, Boolean.class);
		if(flag==true){
			String message= "Customer is succesfully registered!";
			model.setAttribute("message", message);
			return "index";
		}
		else{
			String message= "Another Customer is already registered with this phone number";
			model.setAttribute("message", message);
			return "register";
		}
	}

	@GetMapping("/loginPage")
	public String getLoginPage() {
		return "login"
	}
	
	@GetMapping("/loginCustomer")
	public String loginCustomer(@RequestParam Long phoneNo, @RequestParam String password, Model model, HttpServletRequest request) {
		Login login = new Login();
		login.setPhoneNumber(phoneNo);
		login.setPassword(password);

		boolean flag = retTemplate.postForObject(LOGIN_URL, login, Boolean.class);

		if(flag==true){
			HttpSession session = request.getSession();
			session.setAttribute("phoneNumber", phoneNo);
			return "Home";
		}
		else {
			model.addAttribute("message", "Bad credentials!");
			return "login";
		}
	}
	
	@GetMapping("/profile")
	public String customerProfile(Model model, HttpServletRequest request) {
		HttpSession session = request.getSession();
		Long phoneNo = (Long)session.getAttribute("phoneNumber");
		CustomerDto custDto = restTemplate.getForObject(PROFILE_URL, CustomerDto.class, phoneNo);
		model.addAttribute("customer", custDto);
		return "customerProfile";
	}

	@GetMapping("/plans")
	public String browsAllPlans(Model model) {
		ParameterizedTypeReference<List<PlanDto>> typeRef=new ParameterizedTypeReference<List<PlanDto>>(){};
		ResponseEntity<List<PlanDto>>  re = restTemplate.exchange(ALLPLANS_URL, HttpMethod.GET, typeRef);
		List<PlanDto> planDtoList = re.getBody();
		model.addAttribute("planDtoList", planDtoList);
		return "showPlans";
	}
	
	@GetMapping("/calldetails")
	public String getCallDetails(Model model, HttpServletRequest request){
		HttpSession session = request.getSession();
		Long phoneNo = (Long)session.getAttribute("phoneNumber");

		ParameterizedTypeReference<List<CallDetailsDto>> typeRef = new ParameterizedTypeReference<List<CallDetailsDto>>(){};
		ResponseEntity<List<CallDetailsDto>> re = restTemplate.exchange(CALLDETAILS_URL, HttpMethod.GET, null, typeRef, phoneNo);
		List<CallDetailsDto> dto = re.getBody();
		model.addAttribute("callDetailsDtoList",dto);
		return "showCallDetails";
	}
}



package com.ui.model
public class RegisterBean {}

public class LoginBean {}

public class RegisterBean {
	@NotNull
	private Long phoneNumber;
	private String username;
	private String password;
	private String email;
	private String planId;
	private List<PlanDto> planList;
}


index.jsp
-----------
<%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>
<c:if test= "${message ne null}">
	<c:out value="${message}"/>
</c:if>
<hr>
<a href="registerPage">SignUp</a>
<br>
<a href="loginPage">SignIn</a>

register.jsp
----------------
<%@taglib uri="http://www.springframework.org/tags/form" prefix="form"%>
<%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>
<c:if test= "${message ne null}">
	<c:out value="${message}"/>
</c:if>
<hr>
<form:form action="addCustomer" method="post" modelAttribute="registerBean">
	<table>
		<form:input path="phoneNumber"/>
		<form:errors path="phoneNumber"/>

		<form:password path="password"/>
		<form:errors path="password"/>
		---
		<form:select path="planId">
			<form:option value="">----Select----<form:option>
			<form:options item="${registerBean.palnList}" itemValue="planId" itemLabel="palnId"/>
		</form:select>
		<form:errors path="planId">	

	
		<input type="submit" value="REGISTER">		

	</table>
</form:form>

login.jsp
------------
<%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>
<c:if test= "${message ne null}">
	<c:out value="${message}"/>
</c:if>
<hr>
<form action="loginCustomer" method="post">
	<input type="text" name="phoneNo">
	<input type="text" name="password">

	<input type="submit" value="login">
</form>

Once user logged in successfully, Home.jsp should show.
Images/ js/ css files should be placed in static directory which is : src/main/resources/static/images

Home.jsp
-------------
<table>
	<tr>
		<td>
			<figure>
				<a href="profile" <img src="images/profile.jpg" width=80></a>
			</figure>
		</td>
		<td>
			<figure>
				<a href="plans" <img src="images/plan.jpg" width=80></a>
			</figure>
		</td>
	</tr>
</table>

customerProfile.jsp
--------------------
<%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>
<c:if test= "${message ne null}">
	<c:out value="${message}"/>
</c:if>
<hr>
Phone Number: <c:out value="${customer.phoneNumber}"/><br>
User: <c:out value="${customer.userName}"/><br>
Email: <c:out value="${customer.email}"/><br>
Current Plan Details
PlanId: <c:out value="${customer.currentPlan.planId}"/><br>
Plan Name: <c:out value="${customer.currentPlan.planName}"/><br>
Validity: <c:out value="${customer.currentPlan.validity}"/><br>
description: <c:out value="${customer.currentPlan.description}"/><br>

Friends Contact Numbers
<c:forEach items="${customer.friendsContactNumbers}" var="friendNo">
	<c:out value="${friendNo}"/><br>
</c:forEach>

showPlans.jsp
-------------------
<%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>
<c:set var="count" value="1"/>
PlanId 	Plan_Name 	Validity 	Description
Table
	forEach planDtoList
<c:forEach items="${planDtoList}" var="pdto">
	<c:if test="${count%2!=0}">
		<tr style="bgcolor=green">
			<c:out value="${planId}"/>
			---
			---
	
	<c:if test="${count%2==0}">
		<tr style="bgcolor=blue">
			<c:out value="${planId}"/>
			---
			---

showCallDetails.jsp
------------------------
<%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>
<c:if test="${!empty callDetailsDtoList}">
	<c:forEach items="${callDetailsDtoList}" var="callDetailsDto">
		<tr>
			<td><c:out value="${callDetailsDtoList.calledBy}"/></td>
			<td><c:out value="${callDetailsDtoList.calledTo}"/></td>
			<td><c:out value="${callDetailsDtoList.calledOn}"/></td>
			<td><c:out value="${callDetailsDtoList.durationInSeconds}"/></td>
		</tr>
	</c:forEach>
</c:if>


src/main/resources/messages.properties
NotNull.registerBean.phoneNumber=PhoneNo is Required.
NotNull.registerBean.userName=User Name is Required.
---
---

application.properties
--------------------------
server.port=9890
spring.mvc.view.prefix=/WEB-INF/views/
spring.mvc.view.suffix=.jsp
server.servlet.context-path=/UI


Cloud
============
Cloud enabled - Able to just deploy microservices on cloud platform.

Cloud native - Using the advantages/features of cloud platform like load-balancing, service-registry, etc...

- Making the microservices as cloud native, Spring provided some components like Netflix etc...

For e.g.
-----------
- Customer-microservice is making a call to Friend-microservices.

	- [two instances are running of ms-friend - means running on two different servers.]

	ms-customer[single instance] ---> ms-friend [instance-1 on port-x]
						 ---> ms-friend [instance-2 on port-y]


	- Request from ms-customer has to be load balanced (handling request load) among the ms-friend instances.
	- When there is huge request loads - an application can be load balanced/ running on several instances.


Server side Load balancer
-----------------------------
	- Application running on multiple servers, to load balance requests to different servers, server side load balancer system requires, which forwards requests among the running instances.

		
							   		-------> server1/node1
	requests -----> server side load balancer	-------> server2/node2
							   		-------> server3/node3

	
	- server side load balancer generally uses round robin algorithm.
	
	disadvantages
	-----------------
	- If this load balancer fails, then request can not be reach on nodes, but application is up
	- extra cost to configure load balancer instance.
	- extra networks latency(time to reach nodes) through load balancer to nodes.
	

Client side load balancer
------------------------------
	- spring cloud has resolved these by introducing "Client side load balancer".
	- separate server side load balancer is not required.
	
	
	
								-------> server1/node1
	[client--client_side_load_balancer] 	-------> server2/node2
								-------> server3/node3


	- Here client should know all the running server/nodes informations. 
		
Spring cloud component
--------------------------
	"spring cloud netflix ribbon" - It is a client side load balancer/ load balancing library.

	
					-------> friend instance server1/node1
	[ms-customer+ribbon] 	-------> friend instance server2/node2
					-------> friend instance server3/node3


	- dependencies : Ribbon, Spring Web, Eureka server 
		[Ensure in pom.xml, spring-cloud.version tag is added to properties tag & dependencyManagement & repository of cloud tag also must be there.]

	- need to add ribbon library on ms-customer
		groupId = org.springframework.cloud
		artifactId = spring-cloud-starter-netflix-ribbon


	MsCustomerApplication.java - Register load balance with RestTemplate

	@Bean
	@LoadBalanced
	public RestTemplate restTempl() {
		//Load balanced RestTemplate
		return new RestTemplates();
	}

 	In CustomerRestController.java

	@RestController
	@RibbonClient(name="custRibbon") //From this rest controller all the request will be deligate
	public class CustomerRestController {
	
		@Autowired
		@Qualifier("restTemp")
		RestTemplate restTemplate;

		@Autowire
		@Qualifier("restTempl")
		RestTemplate loadBalancedRestTemplate;

		private static String FRIEND_URL = "http://custoribbon/FriendApi/{phoneNumber}"; //No particular port-ribbon name will deligate to the different load balanced server instances.

		---

		

	}

	application.properties
	-----------------------
	custoribbon.ribbon.eureka.enabled=false #//service descovery 
	custoribbon.ribbon.listOfServers=http://localhost:4343,http://localhost:6363 #different load balanced server instances of friendsApi list
	

Start ms-friend in two different ports: 4343 & 6363
------------------------------------------------------
1) right click on app - Run As - Run Application - it will run on 4343.
2) right click on app - Run As - Run Configuration - left side springBootApp-choose ms-friend - change name at right side then click on environment - add - Name=server.port & Value=6363. start.

start ms-customer app.


Watch microservices class-1(from sdd), class-2 & class-3.

Hystrix
==========
Resilience
------------

	Service1 ==> Service2 ==> Service3

	Suppose service1 is sending requests to Service2, further Service2 requires Service3 to fulfill requests, but Service3 is working slow/down.

	So, Service1 is keep on requesting to Service2 but Service2 is not able to fulfill request due to Service3 is down.
	
	
	To resolve such situation, we need to make the resource system resilient.
		- Open a circuit to stop sending request to Service3 within a time period.


	- When a service a working slow/ down then no need to approach this service to prevent failures/difficulties/errors.

	Here, need to apply circuit breaker pattern - which means within a given timeframe if these many request are sent and number of request are reached to threshhold value & if this percentage of request are failed, then we need to open a circuit to stop sending request.

	If No of request - 20,
	Threshhold - 60%(If 60% of request failed)
	then, no need to open a circuit for a time period(Window Time) to stop sending request. And instead of calling that down service, need to call a callback method to execute default message. Once the circuit is opened then it will check internally that request is up or not. And once service up, circuit will be closed

	- To achieve this, Hystrix API is used. It provides the resilience to the service call.

	For e.g.,
	Customer-ms ----calling-----> friend-ms

	1) Define a hystric service & hystrix command in customer
	2) Define a callback method in customer
	3) Dependency in customer pom.xml - spring-cloud-starter-netflix-hystrix
	4) Add Hystrix properties application.properties
	4) @EnableCircuitBreaker in customer

	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-starter-netflix-hystrix</artifactId>

	- Define a hystrix command as a Bean
		
	import com.customer.breaker;
	@Component
	public class CircuitBreaker {
		
	}
	

API Gateway
=================












arn:aws:s3:::nidarshan-s3/index.html

https://nidarshan-s3.s3.us-east-2.amazonaws.com/index.html
http://localhost:7791/api/media/downloadFile/niteshnidarshan5.jpg




Oauth/ Oauth2 securities for Rest Services





Piyush Priyadarshi 9000585533 - call him @2:00 pm - manager - epam

	
https://ssc.larsentoubro.com/SALUX
Abc@123321

	

	
 





















