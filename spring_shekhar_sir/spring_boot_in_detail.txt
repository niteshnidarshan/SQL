class material link-> [https://groups.google.com/forum/#!forum/test_examples]

Spring Boot is a new model to develop spring applications.

Features
-----------
1) Flexibility over configuration - Annotation, java config classes or zero configurations.

2) Starters dependency - (Combination of required jars)
	- A group of related dependencies with appropriate versions.

3) Embedded server - (Tomcat, Jetty etc.)

4) Profiles (To make application compatible for different environments - just need to activate the related profile at the time of development)

5) Actuators - Inside details of application during runtime like heap size, memory information, server status etc.


SpringBoot Core/ AOP
SpringBoot MVC
SpringBoot Data JPA
SpringBoot Data MongoDB
SpringBoot Security
SpringBoot Restful Web services
SpringBoot Data Redis
SpringBoot Security Oath2
SpringBoot Profiles
SpringBoot Actuator
SpringBoot Batch
SpringBoot Kafka

Monolithic application - Single jar/ war for whole application
------------------------------------------------------------------
- It has the following drawbacks

	1) Large App 
		- Increase development time, may cause downtime during deployment even though changes are very small.
		- Large deployment & startup time
	2) Scaling
		- Difficult to handle when large traffic for a single module, entire application goes down.

	3) One Technology Stack -Entire development is done only with one technology, Other language/ technology support not available.

Solution of Monolithic approach is - Micro-services.

Micro-services
------------------
- Split of large system into smalls.
- Independent responsibility for each micro services.
- Scaling [If one micro-service is having downtime/ load - only that particular micro-service can be scaled up without interrupting others.]
- Multi language development possible (Interoperability). 


pom.xml
===============
1) Add <parent> tag - above dependency tag
	
	<parent> 
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.3.1.RELEASE</version>
	</parent>

2) Add dependencies
	
	<dependency>	
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter</artifactId>

		/* Here version is automatically inherited from parent, so no need to provide */ 

	</dependency>

3) Add plugin

	- Spring boot provided plugins to maven to build, run, test & package for war/jar with goal etc...

	<plugin>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-maven-plugin</artifactId> /* To build & execute spring boot app */
	</plugin>


- In order to migrate existing application, add these three tags in pom.xml
- To create new spring boot project, needs spring initializer tool which adds all the stuffs in pom.xml like start.spring.io
- Every spring boot application have entry point class with main method and application executes from this main method only.
- The entry point class must have annotated with @SpringBootApplication. 
- @SpringBootApplication consist of three annotations :
	[@Configuration / @SpringBootConfiguration + @ComponentScan + @EnableSpringBootConfiguration].


@SpringBootApplication
---------------------------------
	- class level annotation
	- entry point of spring boot application
	- combination of :
		- @SpringBootConfiguration (or SpringConfiguration - both are same)
		- @EnableAutoConfiguration (Automatically configures jars which are available in class path)
		- @ComponentScan
	- The class annotated with @SpringBootApplication, acts also as a configuration class and the class can contain bean configurations methods.
	- Spring boot application runs as a SpringApplication.

spring-boot-configuration module - contains auto configuration classes
	for e.g. 
	-----------
	spring-boot-starter-web - spring-boot-configuration module configures all the jars associated this starter dependency automatically.


@SpringBootApplication
public class DemoApp {
	public static void main(String args[]){
		
		SpringApplication.run(DemoApp.class, args);
		
		// BOOTSTRAPPING
		//-------------------
		//run is a static method and does the following internally :
		//1) creates ApplicationContext (A type of container which manages entire beans) - loads all the beans of the application to the 						ApplicationContext with the help of DemoApp.class.
		//2) registers CommandLinePropertySource bean (This class Converts command line arguments to spring application properties)
		//3) refreshes ApplicationContext with singleton beans
		//4) triggers CommandLineRunner bean classes

		//- Just before ready to run spring boot application, CommandLineRunner executes(If you want to execute any logic one time just before spring boot application is going to start. for e.g. - like load all the job schedules from database or to insert users with encrypted password for admin users to database.)
		- CommandLineRunner is an interface provides a method run().
		- We can define multiple CommandLineRunner by implementing in our classes, but needs provide order of execution else will run randomly.

		// These all four steps are called bootstrapping(initialising the application).
		
	}
}

CommandLineRunner implementation (by custom)
---------------------------------------------
@Component 
@Order(2) // Defines execution order for the class - low the number higher the priority
public class LoadSchedulesRunner implements CommandLineRunner {
	@Override
	public void run(String... args) {
		//logic
	}
}

@Component 
@Order(1)
public class DataRunner implements CommandLineRunner {
	@Override
	public void run(String... args) {
		//logic
	}
}

$mvn spring-boot:run //Maven uses Spring boot maven plugin to compile & run

$java -jar filename.jar

Deploy Docker image in cloud

CommandLinePropertySource
----------------------------
 - If any value passed by command line argument, it reads those & add to the 'Environment Object' of the application.
 
 - It is similar to write properties in application.properties/ application.yml

  
 

9505360660 - mohd. Basith. - Sathya Tech - 5000 - google pay
send screenshot of payment to 9100920092 whatsapp.

paid

-----------------------------------------------------------------


Spring Boot - Summary
-----------------------
# Why boot?
	- Zero/Less configuration
		* Earlier Spring has provided flexibility to define configurations in multiple ways like xml, annotations, java configuration classes.
	- Starter dependency
		* Boot provided combination of compatible dependency in a single starter dependency
	- Embeded server
		* Earlier had to deploy jar/war to server manually.
	- When application moves on from one environment to another then you had to change application properties manually.   
	
- Spring Boot is a new model to create spring applications, but it is not a new framework

- Features
	* Zero or Minimal configurations
	* Starter Dependencies
	* Embedded servers
	* Opinionated view - Default configuration with customisations 
	* profiles
	* actuators - Production ready features

- Requirements for Spring Boot		
	1) Java 8+
	2) Maven/ Gradle

- Changes to pom.xml
	1) Add parent tag
	2) Add starter dependencies
	3) add plugin
	
- If you want to migrate a spring application to spring boot application, you need to add the changes to pom.xml manually.

- A new spring boot applications are generated through spring initialiser tool, which automatically adds the required changes in pom.xml.


@SpringBootApplication
-------------------------
* Every spring boot application executes from java main(). 
* To make a class as an entry point for spring boot project, add @SpringBootApplication on class 
* @SpringBootApplication = @SpringBootConfiguration + @EnableAutoConfiguration + @ComponentScan
* Every spring boot application class is a configuration class, in which you can define bean methods to customize the configurations.
* In spring boot, we have auto configure module with a group of auto configuration classes which automatically adds the required bean configurations based on the jars available on classpath.

com.pack // base package - contains main method - does auto configure from its package.  
com.pack.service
com.pack.controller
com.pack.entity
com.pack.model
com.pack.dao
com.pack.utilities

* Bydefault, components auto scan starts from spring boot application's base package to its sub packages.
It can be customized with scanBasePackages element.
(If configuration available in package other than base package path) 

@SpringBootApplication(scanBasePackages={"package1", "package2", ...})

SpringApplication.run()
----------------------------
* Spring boot has provided SpringApplication class, to run a spring boot application as a spring based application from java main method.
* The run() has two parameters : 
	1) Spring Boot Application class Class object
	2) command-line arguments

for e.g.
----------
@SpringBootApplication
public class DemoApplication {
	psvm(String args[]) {
		SpringApplication.run(DemoApplication.class, args);
	}
}

Stereo type annotations - defines role of the class
----------------------------------------------------------
@Component - spring bean class
@Service
@Controller
@RestController
@Repository 
@Configuration - java configuration class

CommandLineRunner
---------------------
- Triggers just before running spring boot application.
- Multiple CommandLineRunner can be defined with run order.

STS(Spring Tools Suite) IDE - File - new Spring Starter Project 
Name - Demo1 | Type - Maven | Packaging - jar | Java Version - 8
Group(Organisation) - com.sathyatech
Artifact(Project Name) - Demo1
Version 1.1
package(Base package) - com.demo

Next - Spring Boot Version - 2.3.3 | Dependencies - ...if any like web, lombok etc. (If not add any dependency, it will be added Spring-Boot-Starter dependency only).

pom.xml - plugin(spring-boot-maven-plugib) - spring provided this plugin to build & run spring boot application.

Demo1Application.java - this class is created automatically according to the Project name.

@SpringBootApplication
public class Demo1Application {
	psvm(String args[]) {
		SpringApplication.run(Demo1Application.class, args);
	}
}

package com.demo.bean;
@Component
public class HelloWorldBean {
	public String sayHello() {
		return "Hello World";
	}
}

package com.demo.runner;
@Component
public class MyRunner implements CommandLineRunner{
	@Autowired //Object/collection dependencies - if bean is conflicting then use @Qualifier
	HelloWorldBean helloWorld;

	@Override
	public void run(String... args) throws Exception{
		System.out.println(helloWorld.sayHello());
	}
}

Go to main() class & run as java application.
or
manven - maven build ... - command = build
project - target - Demo1-1.1.jar
$ [go to project path]
$ java -jar target/Demo1-1.1.jar
or 
$ mvn spring-boot:run

If mvn is showing error like - not a command
- download maven, extract & set maven on environmental path
- apache-maven-3.5.2\bin : add this to path variable.
 
$ mvn --version
$ mvn clean package [clean - to clean previous build, package - packaging jar]
$ mvn spring-boot:run - to run boot project inside the project directory

Application properties is set by either of :
1) application.properties
2) application.yaml
3) command line argument
4) CommandLineRunner class

command line argument has two types
1) Optional arguments [contains key=value, starts with '--']
	for e.g.
	---------
	$ java -jar target/filename.jar --key=value

2) Non-optional arguments [contains only value]

	for e.g. 
	------------
	$ java -jar target/filename.jar --key=value --key=value nonoptional1 nonoption2


ApplicationRunner interface
--------------------------------
- like CommandLineRunner interface & it has also a run() but it takes ApplicationArguments

- run(ApplicationArguments args)

- ApplicationArguments separates Optional & non-optional command line arguments.

- If you want to set properties at the time of runtime then go for ApplicationRunner.

with @Values can be injected values to the bean - It is called value injection.


@Component
public class HelloWorldBean {
	//@Value("Hello World")
	@Value(${msg.key})
	String message;

	public String sayHello() {
		return message;
	}
}

application.properties
--------------------------
msg.key=Hello World!


- If we provide value at runtime with argument, it will override application properties value.
$ java -jar target/Demo-1.1.jar --msg.key="It's a boot application" [This message will be shown].

So, command line argument has high priority.

If properties file name is not "application.properties" then use @PropertySource(classpath:myfile.properties) in @SpringBootApplication class

create a spring core app : 
-----------------------------
package com.demo
@SpringBootApplication
public class Demo2Application {
	psvm(String args[]) {
		SpringApplication.run(Demo2Application.class, args);
	}
}

package com.demo.runner;
@Component
public class MyApplicationRunner implements ApplicationRunner {
	@Override
	public void run(ApplicationArguments args) throw Exception {
		//ApplicationArguments has separate methods for option & nonoption arguments 

		//To print all Non-option args
		List<String> nonOptionArgsList = args.getNonOptionArgs();
		sysout("Non-option args from command line : ");
		nonOptionArgsList.forEach(System.out::println);

		sysout("=====================");

		//To print all option args
		//One key can have multiple values.
		Set<String> optionArgsNames = args.getOptionNames();
		optionArgsNames.forEach((name)-> {
			List<String> optionArgValues = args.getOptionValues(name);
			System.out.print(name + " : "); //name
			optionArgValues.forEach(System.out::print+" "); //associated values
		}); 
	}
}

$ mvn spring-boot:run -Dspring-boot.run.arguments="--id=101 --name=Stahya,Shekher Amirpet Hyderabad"
or
$ java -jar target/Demo2-1.1.jar --id=101 --name=Stahya,Shekher Amirpet Hyderabad

$ java -jar target/Demo2-1.1.jar --id=101 --name=Stahya,Shekher Amirpet Hyderabad --id=10001

Note : id=10001 does not override id=101. It will keep both with coma sepearted


To Autowire Option & Non-Option args in a class
----------------------------------------------------

@Component
public class Warehouse {
	List<String> warehouseTypes;

	@Autowired
	ApplicationArguments args;

	public void addWarehouseTypes(){
		List<String> list = args.getNonOptionArgs();
		list.forEach(value->warehouse.add(value));
	}
}

Command Line Arguments
------------------------------
CommandLineRunner - run(String... args)
ApplicationRunner - run(ApplicationArguments args)

Command line arguments
1) option args [--key=value]
2) non-option args [value]

- application.properties - define arguments here at development time.

- Command Line Arguments override application.properties values.

For e.g with DI
------------------------
package com.demo.bean;
@Component
public class PolicyBean{

	@Value("${policy.company}")
	String policyCompany;
	
	List<String> policyTypes = new ArrayList<String>();

	@Autowired
	ApplicationArguments args;

	public void showDetails() {
		List<String> nonOptionArgs = args.getNonOptionArgs();
		nonOptionArgs.forEach((name)->{
			policyTypes.add(name);
		});
		
		sysout("Policy company: "+policyCompany);
		sysout("Policy Type: ");
		policyTypes.forEach(System.out::println);
	}
	
}

package com.demo.runner;

@Component
public class MyRunner implements CommandLineRunner {
	@Autowired
	PolicyBean policyBean;

	@Override
	public void run(String... args) throws Exception {
		policyBean.showDetails();
	}
}

application.pproperties
------------------------
policy.company=LIC

- package it 

$ java -jar target/Demo3-1.1.jar --policy.company="LIC Of India" "Endowment Plan" "Term Insurance Plan" "Money Back Plan"

- We can make the main class of spring boot app also a CommandLineRunner like this - because @SpringBootApplication is also a @Component : 
@SpringBootApplication 
public class Demo3Application implements CommandLineRunner {
	@Autowired
	PolicyBean policyBean;

	public static void main(String args[]){
		SpringApplication.run(Demo3Application.class, args);
	}

	@Override
	public void run(String... args) throws Exception {
		policyBean.showDetails();
	}
}


CommandLineRunner
---------------------
	- Implement this interface into a class to define a code to run before a spring boot application's bootstrapping is going to finish.
	- Just before a spring boot application becomes ready to use by the users, the command line runner beans of application will be executed.
	- You can define multiple CommandLineRunner and define the order of their executions with @Order.

ApplicationRunner
-------------------
	- It is also like CommandLineRunner only, but it provides a run() with ApplicationArguments parameters to access option and non-option arguments separately.
	- An option argument has a key-value. [--key=value]
	- An option argument has a value only. [without --]

	$ java -jar target/appname.jar --key=value --server.port=2020 --db.user=system IamNonOption1 "I am Non Option2"
	
	$ mvn spring-boot:run -Dspring-boot.run.arguments="--key=value --server.port=2020 --db.user=system IamNonOption1 'I am Non Option2'"


Spring-JDBC [spring-boot-starter-jdbc & DB Driver dependencies]
=================================================================== 
	- Checked exception
	- No boiler plate code
	- Provides an abstraction layer over JDBC - JdbcTemplate class
		- JdbcTemplate class depends on DataSource[interface].
			DataSource[interface] implementation :
				- DriverManagerDataSource class
				- HikariDataSource class

 
	
spring-jdbc project
------------------------
	pom.xml
	--------------------------
	- spring-boot-starter-jdbc(JDBC API) & Oracle Driver(ojdbc8) dependencies
	
	application.properties
	--------------------------
	spring.datasource.driver-class-name=oracle.jdbc.driver.OracleDriver
	spring.datasource.url=jdbc:oracle:thin:@localhost:1521:xs
	spring.datasource.username=system
	spring.datasource.password=tiger

	package com.demo.dao;
	public interface EmpDaoIntf {
		void updateEmp(double salary, int deptno);
		Map findEmpById(int empno);
		List<Map<String, Object>> findAll();
	}

	package com.demo.dao.impl;
	@Repository
	public class EmpDaoImpl implements EmpDaoIntf {

		@Autowired 
		JdbcTemplate jdbcTemplate;

		@Override
		void updateEmp(double salary, int deptno){
			jdbcTemplate.update("UPDATE EMP SET SAL=? WHERE DEPTNO=?", salary, deptno);
		}

		@Override
		Map findEmpById(int empno) {
			return jdbcTemplate.queryForMap("SELECT * FROM EMP WHERE EMPNO=?",empno); //Single record selection
		}

		@Override
		List<Map<String, Object>> findAll() {
			return jdbcTemplate.queryForList("SELECT * FROM EMP"); //Multi row records
		}
	}

	package com.demo.runner;
	@Component		
	public class MyRunner implements CommandLineRunner {
		@Autowired
		EmpDaoIntf intf;

		@Override
		public void run(String... args) throws Exception {
			intf.updateEmp(5999.0, 20);
			
			sysout(intf.findEmpById(7788));

			List<Map<String, Object>> list = intf.findAll();
			list.forEach(System.out::println); 
		}
	}
	
	run app 

Spring Boot MVC
==================
- Web applications can be created using Servlet & JSP technologies which provides tightly coupled solution.
- Model(data/business), view(presentation), controller(navigates between model & view).
- Front Controller (DispatcherServlet) - Controls each & every request

- In java MVC & MVC2 architectures are there.
	- In MVC(No Helper class), front controller contacts with appropriate Model directly then controller decides appropriate view.
	- In MVC2(Use Helper class), front controller servlet use Helper classes to identify Model & View classes. 
	- Spring MVC follows MVC2 architecture where need to configure servlet_name-servlet.xml and also need to add DispatcherServlet to web.xml 
		WEB-INF/ web.xml & <servlet_name-servlet.xml> files
		web.xml
		--------------
		<web-app>
			<servlet>
				<servlet-name>spring</servlet-name>
				<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
				<load-on-startup>1</load-on-startup> //for early load of servlet.
			</servlet>
			<servlet-mapping>
				<servlet-name>spring</servlet-name>
				<url-pattern>/</url-pattern>
			</servlet-mapping>
		</web-app>
	- Spring boot MVC - No need to configure web.xml or view response 

	spring MVC
	-----------
		Controller
		---------------
		@Controller - class level annotaion
		@RequestMapping/ @GetMapping/ @PutMapping/ @PostMapping/ @DeleteMapping - Method level annotations 
	

		@Controller
		public class UserController { //Controller Bean class

			//Old style
			@RequestMapping(value="/getUsers", method = RequestMethod.GET)
			public ModelAndView findUsers() {
				---
				---
			}

			//New Style
			@GetMapping("/getUsers")
			public ModelAndView findUsers() {// findUsers() is called Handler Method
				---
				---

				return new ModelAndView("view_name", "model_name", model_value); //String, String, Object -- will return view_name.jsp
				//InternalResourceViewResolver - to resolve a view name to actual view by adding a prefix & suffix - which needs to configure.
 
			}

		}
 

		1) DispatcherServlet calls HandllerMapping[RequestMappingHandlerMapping] bean to identify appropriate Controler
		2) HandllerMapping[RequestMappingHandlerMapping] bean returns appropriate Controller which associates the request to DispatcherServlet.
		3) Then DispatcherServlet calls that Controller bean.



	@Controller
	public class EmployeeController {
		@GetMapping("/index")
		public ModelAndView getIndexPage() {
			return new ModelAndView("index");
		}
	}
	
	@GetMapping("/employee/deptno") 
	public ModelAndView getEmployeesByDeptno(int deptno) {
		List<Employee> wmpList = service.findEmpsByDno(deptno);
		return new ModelAndView("show", "employee", empList);
	}


	- In SpringBoot by default InternalResourceViewResolver class is associated for View Resolver bean. It maps the view name to actual view.
	- InternalResourceViewResolver maps actual view by appending prefix & suffix.
		prefix = "/WEB-INF/views/"
		suffix = ".jsp"

		So, "/WEB-INF/views/show.jsp" will be the response for the DispatcherServelt, then DispatcherServelt renders show.jsp & responds.
	
		/WEB-INF/views/*.jsp

	- In SpringBoot prefix & suffix to be set in application.properties

	- Web applications are created to share resources. these resources may be a page/data/functionality.


	Current development scenario - No need to return ModelAndView object, just need to set model data to ModelMap & return view name 
	----------------------------------------------------------------------------------------------------------------------------------
	@GetMapping("/employees")
	public String getEmployees(ModelMap model) { //ModelMap is a type of Map only, instead of ModelMap it can be used Model/ Map**
		List<Employee> employeesList = service.findEmployees();
		model.addAttribute("employees", employeesList); //Model is set to ModelMap
		return "show"; //Returns only view name
	}
	
	**ModelMap extends LinkedHashMap implements Model [Model is from spring]

	Simple Spring MVC(No Spring boot) application development requires :
	------------------------------------------------------------------------
	1) MVC related dependencies to pom.xml
	2) add DispatcherServlet configuration to web.xml
	3) define spring configuration in dispatcher-servlet.xml
	4) deploy war on a server


	Spring boot MVC application development requires :
	-------------------------------------------------------
	1) add spring-boot-starter-web in pom.xml
	2) add server/ prefix/ suffix properties in application.properties
	3) run application

	Create application - starts.spring.io
	-------------------------------------------
	dependencies - 
	----------------
	1) spring-boot-starter-web
	2) //If jsp is a view
		<groupId>org.apache.tomcat.embed</groupId>
		<artifactId>tomcat-embed-jasper</artifactId>

	application.properties
	----------------------------
	server.port=2223
	server.servlet.context-path=/mvc
	spring.mvc.view.prefix=/WEB-INF/views/
	spring.mvc.view.suffix=.jsp

	
	package com.mvc.controller;
	@Controller
	public class HelloController {
		@GetMapping("/hello")
		public String returnWelcomePage() {
			return "welcome";
		}
	}

	create a jsp file in this directory :
	/src/main/webapp/WEB-INF/views/welcome.jsp
			
	welcome.jsp
	---------------
	<h1>Jai Ram G ki</h1>

	
	run & request as http://localhost:2223/mvc/hello


pom.xml
--------------
<dependency>
	<groupId>jstl</groupId>
	<artifactId>jstl</artifactId>
</dependency>

application.properties
---------------------------
server.servlet.context-path=/Train
spring.mvc.view.prefix=/WEB-INF/views
spring.mvc.view.suffix=.jsp


@Repository
public class TrainDaoImpl implements TrainDaoIntf {
	@Autowired
	JdbcTemplate jdbcTemplate;
	
	public Train findTrain(Integer trainno) {
		Map map = jdbcTemplate.queryForMap("select * from train_details where train_no = ?", trainno);
		
		Train train = new Train();
		BigDecimal bd = (BigDecimal)map.get("train_no");
		Integer trno = bd.intValue();
		train.setTrainno(trno);
		train.setSource(map.get("source").toString());
		train.setDestination(map.get("destination").toString());

		//Here RowMapper can be used to map object with POJO automatically.
	}
}

@Controller
public class TrainController {
	@Autowired
	TrainDaoIntf intf;

	@GetMapping("")
	public String {
		return "search";
	}

	@GetMapping("")
	public String searchTrainByNo(@RequestParam Integer trainno, Model model){
		Train train = intf.findTrain(trainno);
		model.addAttribute("train", train);
		retrun "result";
	}
	
	
}

result.jsp
--------------
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%> //EL - expression language/ jstl tag
<table>
	<tr>
		<th>Train#</th>
		<th>Source</th>
		<th>Destinaion</th>
		<th>Dept time</th>
		<th>Arr time</th>
	</tr>
	<tr>
		<td><c:out value="${train.trainno}"/></td>
		<td><c:out value="${train.source}"/></td>
		<td><c:out value="${train.destination}"/></td>
		<td><c:out value="${train.depttime}"/></td>
		<td><c:out value="${train.arrtime}"/></td>
	</tr>

</table>


Data Binding
=================
- By binding a UI form with application object, we achieve data binding.
- With JSP it can be achieved by adding the tag library as 
- WebDataBinder - DispatcherServlet calls WebDataBinder to bind UI controls to bean.

	<%@taglib uri="http://www.springframework.org/tags/form" prefix="form"%>

	<form:form action="xxx" modelAttribute="userData">//form tag - first form is prefix & second one is tag name
											    //add javaBeanObject(userData) with a name in ModelMap of spring

	@Controller
	public class UserController {

		@GetMapping("/userForm")
		public String getUserFormPage(Model model) {
			UserBean userBean = UserBean();
			model.addAttribute("userData", userBean);
			return "user";
		}
	}

On click of Submit button in UI, associated url is handled by the handler method to read the data,
which uses @ModelAttribute to bind method parameter to the model attribute.

Submit form -> @Controller -> 

@Controller
public class UserController {
	@GetMapping("/xxx")
	public String getUserPage() {
		//code
	}

	@PostMapping("/addUser")
	public String addUserDetails (@ModelAttribute UserBean userBean) {
		//code
	}
} 

	
Data Validation
===================
- Javascript validation is done on client side which is not much secure, for this need to validate data on server side.
- To validate data at server side, spring framework has not given any annotations.
- Sun has provided Bean Validation API(in interfaces) to validate data on java bean class with annotation.
- Hibernate has provided its implementation as Hibernate validator API.
- For this need to use dependency - spring-boot-starter-validation.
- WebDataBinder - DispatcherServlet calls WebDataBinder to bind UI controls to bean.

@AssertTrue
private boolean isActive; //Field value must be true

@AssertFalse
private boolean isDeleted; //Field value must be false

@NotEmpty //Can be applied only in String field
String userName; //userName should not be empty. else validation error.

@Size(min=5, max=10) //Can be applied only in String field
String password; 

@NotNull 
Date dob;

@NotNull //can be applied on objects, enum etc.
Gender gender;

@NotEmpty
@Email
String email;

@Min(18)
@Max(21)
Integer age; //@Min, @Max can be used with Integer, int, short, long.

@DecimalMin(15.15)
@DecimalMax(25.25)
Double price; // For decimal(float/ double)

@Past
@Future
Date field; // With date fields

@Pattern(regex="")
String code; // Can be applied on String field only

^ = used to match beginning of the value.
^[A-Z]

$ = used to match end of the value.
[0-9]$

* = 0 or multiple characters.
[a-z]*

+ = 1 or multiple characters.

[a-z]{10} = should be 10 lower case letters.
[a-z]{5,8} = minimum 5 & maximum 8 lower chars.

@Pattern(regex="^[A-Z][a-z]*")
String userName; //first char would be capital & rest of the char should small.

Handling error message
--------------------------
- should be defined in "messages.properties" file(file name must be messages.properties) & put this file in resources directory with application.properties.
- must be followed below convention for mesage :
	constraint.commandname.field=error message

	for e.g.
	---------------
	NotEmpty.userBean.userName=Username is required. //userBean is ModelAttribute name.

	in jsp
	---------------
	<form:errors/> //This tag is used to show the error message at a time or nearby each & every fields.


- BindingResult object stores all the validation errors.
	@PostMapping("/xxx")
	public String doRegister(@Valid @ModelAttribute UserBean userBean, BindingResult result){
		//@ModelAttribute binds method parameter to ModelAttribute
		//@Valid is indicating that the parameter bean is validated
		//This handler method requires BindingResult object to store all the error messages while validate.
		if(result.hasError()){
			return "registration";//Returning same page, error messages will be appended by BindingResult.
		}
		else
		{
			//code
		}
	}


Spring email API 
-------------------
JavaMailSender interface - JavaMailSenderImpl class - with SMTP server
- To send email without attachment - SimpleMailMessage class is used

Example[register-login system]
---------------------------------
If user not registered, system should show error message in the page & redirects to register by entering email.

index.jsp [http://localhost:8080/crm/index]
--------------------------------------------
DispatcherServlet(stops request) 	<-> HandlerMapping
						<-> RegisterController
						<-> ViewResolver
						->  view -> New User? Sign Up -> DS -> RegisterController -> view(register.jsp) -> 	First Name__________
								 Existing User? Sign in									Last Name___________
																					email_______________
																							submit

Submit -> DS -> RegisterController -> EmailService - send success email to user.

Login -> DS -> LoginController -> success.jsp/ error/login.jsp


Customer registration application with spring email, validation & data binding
================================================================================
project name = crm
package = com.crm
dependencies = JDBC API, Spring Web, Validation, Oracle Driver(ojdbc8), Java Mail Sender(spring-boot-starter-mail), org.apache.tomcat.embed(tomcat-embed-jasper) & jstl(jstl) 1.2

src/main/webapp/WEB-INF/views

com.crm.controller
com.crm.model
com.crm.service
com.crm.dao
com.crm.dao.impl
com.crm.service

@Repository
public class RegisterDaoImpl implements IRegisterDao {
	@Autowired
	JdbcTemplate jdbcTemplate;
	
	public boolean saveCustomer(CustomerBean customerBean){
		int count = jdbcTemplate.queryForObject("Select count(*) from customer_tab where email=?", Integer.class, customerBean.getEmail());
		if(count==1){
			return false;
		}
		else{
			jdbcTemplate.update("insert into customer_tab(email, first_name, last_name) values(?,?,?)", );
			return true;
		}
	}
	
}

@Component
public class RegisterController {
	@Autowired
	EmailService emailService;

	@Autowired
	IRegisterDao registerDao;

	@GetMaipping("/index")
	public String getIndexPage() {
		return "index";
	}

	@GetMapping("/register") 
	public String getRegisterPage(Model model){
		CustomerBean customerBean = new CustomerBean();
		model.addAttribute("custBean", customerBean); //adding customerBean to model for Data Binding with UI
		return "register";
	}

	@PostMapping("/save")
	public String registerCustomer(@Valid @ModelAttribute("custBean") CustomerBean customerBean, BindingResult result, Model model, HttpServletRequest request) {
		if(result.hasErrors()) {
			return "register";
		}
		else{
			boolean flag = registerDao.saveCustomer(customerBean);
			if(flag==false){
				model.addAttribute("message", "Customer already registerd. try another Id");
				return "register";
			}
			else{
				//send email to customer for register
				String name = customerBean.getFirstName()+" "+customerBean.getLastName();
				emailService.sendEmailToCustomer(customerBean.getEmail(), name);
				return "registrationSuccess";
			}
		}
	}
}

@Service
public class EmailService {
	@Autowired
	JavaMailSender mailSender;

	public void sendEmailToCustomer(String mailId, String name){
		SimpleMailMessage mailMessage = new SimpleMailMessage();
		mailMessage.setTo(mailId);
		mailMessage.setSubject("");
		mailMessage.setText(name+"");
		mailMessage.send();
	}
}

package com.crm.model;
public class CustomerBean {
	@NotEmpty
	private String firstName;
	
	@NotEmpty
	private String lastName;
	
	@NotEmpty
	@Email
	String email;

	@Pattern(regexp="^[a-z][a-z0-9#@!]*")
	@Size(min=8, max=15)
	private String password;

	@Min(21)
	@Max(35)
	@NotNull
	private Integer age;

	@NotNull
	private Gender gender;

	@NotNull
	private String country;

	@NotNull
	@Past
	@DateTimeFormat(pattern="yyyy-MM-dd")
	private Date dateOfBirth;

	@NotNull
	private Long contactNumber;

	private Map<String, String> countries = new HashMap<>();
	
	//assign countries in constructor
	public CustomerBean() {
		//put some countries values in map.
	}
	
}

public enum Gender {
	MALE, FEMALE, OTHER
}

@Controller
public class LoginController {
	@Autowired
	ILoginDao dao;
	
	@GetMapping("/login")
	public String getLoginPage(Model model){
		model.addAttribute("loginBean", new LoginBean());
		return "login";
	}
	
	@PostMapping("/userLogin")
	public String userLogin(@ModelAttribute LoginBean loginBean, Model model) {
		boolean flag = dao.loginCheck(loginBean.getEmail(), loginBean.getPassword());
		if(flag==false){
			model.addAttribute("msg", "Bad Credential");
			return "login";
		}
		else{
			return "loginSuccess";
		}
	}
}

@Repository
public class LoginDaoImpl implements ILoginDao {
	@Autowired
	JdbcTemplate jdbcTemplate;

	public boolean loginCheck(String email, String password){
		
	}
}

public class LoginBean {
	private String email;
	private String password;

	//Getter-Setter
}


index.jsp
-----------
New User? <a href="register">Sign UP</a><br>
Existing User? <a href="login">Sign In</a>

register.jsp
---------------
<%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>
<%@taglib uri="http://www.springframework.org/tags/form" prefix="form"%>

<c:if test="${message ne null}">
	<c:out value="${message}"/>
</c:if>


<form:form action="save" method="post" modelAttribute="custBean"> //save is a url
<table>
	<tr>
		<td>FirtName</td>
		<td><form:input path="firstName"/></td>
		<td style="color:red"><form:errors path="firstName"/></td>
	</tr>
	
	---
	---
	---
	<tr>
		<td>DOB</td>
		<td><form:input type="date" path="dateOfBirth"/></td>
		<td style="color:red"><form:errors path="dateOfBirth"/></td>
	</tr>

	<tr>
		<td>Country</td>
		<td>
			<form:select path="country"/> 
				<form:option value="">--select country--</form:option>
				<form:options items="${cutBean.countries}"/> //for data loop
			</form:select>
		</td>
	</tr>
</table>
</form:form>

registrationSuccess.jsp
----------------------------
You have registered successfully! Now go to index page.
<a href="index">Home</a>

login.jsp
---------------
<c:if test=${}>
<form:form action="userLogin" method="post" modelAttribute="loginBean">
	<table>
		Email
		Password
		Submit
	</table>
</form:form>

messages.properties
-------------------------------
#error messages

NotEmpty.custBean.firstName=First Name is required

NotEmpty.custBean.lastName=Last Name is required

NotEmpty.custBean.email=Email is required
Email.custBean.email=Invalid email

Min.custBean.age=Age must be >= 21
Max.custBean.age=Age must be <= 25


application.properties
--------------------------
server.port=2221
server.servlet.context-path=/CRM
spring.mvc.view.prefix=/WEB-INF/views/
spring.mvc.view.suffix=.jsp

#DataSource properties
spring.datasource.driver-class-name=oracle.jdbc.driver.OracleDriver
spring.datasource.url=jdbc:oracle:thin:@localhost:1521:xe
spring.datasource.username=xxx
spring.datasource.password=xxx

#Email SMTP properties
spring.mail.host=smtp.gmail.com
spring.mail.port=587
spring.mail.username=
spring.mail.password=
spring.mail.properties.mail.smtp.starttls.enable=true
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.ssl.trust=smtp.gmail.com

#go to email settings, privacy & enable less secure app access



Spring Boot Data JPA
==========================
- There are a various ways to connect spring application with database

	# Spring data access module provides for CRUD operations(Spring's aim to eliminate Dao implementation class):
		1) spring-jdbc-api 
		2) spring-orm-api

	Why Spring Data?
	-------------------
	- Spring's aim to eliminate Dao implementation class from user point of view. Only need to create a Dao interface.
	- Only need to declare methods(additional operations if required) in Dao interface.
	- All the declared methods implementation is provided by spring data at runtime.

	Spring Data Project[Main Project]
	--------------------------------------
		# Spring Data Commons [PagingAndSortingRepository + CrudRepository interfaces] [core-project] - Contains common behaviours 
		- JPA [] [sub-project]
		- MongoDb [MongoRepository] [sub-project]
		- Redis [sub-project]
		- Couchbase [sub-project]
		- Casandra [sub-project]

	* PagingAndSortingRepository extends CrudRepository

		#CrudRepository
		- save(entity)
		- flush() - To sync with database
		- deleteById(Id)
		- deleteAll()
		- findById(Id)
		- findAll()
		- existById(Id)

		#PagingAndSortingRepository
		- findAll(Sort sort)
		- findAll(Pageable pageable)

	* JPA(Java Persistence API specification from Sun to map java classes with table & JPQL) [JpaRepository interface]
		- JPQL(Java Persistence Query Language)
		** JpaRepository extends PagingAndSortingRepository ( -> CrudRepository)

		- By default Spring boot uses Hibernate as a JPA Provider.


	- One application may have many Entity; For each Entity should have separate Repository would be there to perform CRUD operations.


	For e.g
	-------------
	@Entity
	public class Stock {
		
	}

	@Repository
	public interface StockRepository extends JpaRepository<Stock, Entity_Id_data_type>{}
	
	@Entity
	public class Warehouse{
		
	}

	@Repository
	public interface WarehouseRepository extends JpaRepository<Warehouse, Integer>{}


	- Need to create separate Repository for each Entity.
	

class material link-> [https://groups.google.com/forum/#!forum/test_examples]

 
Need to consider for SPRING DATA JPA project
-----------------------------------------------
1) Enable JpaRepository [<jpa:repositories>]
2) configure DataSource bean
3) configure LocalContainerEntityManagerFactory bean
4) configure HibernateJpaVendorAdaptor
5) add multiple dependencies to pom.xml


Need to consider for SPRING BOOT DATA JPA project
---------------------------------------------------
1) add spring-boot-starter-data-jpa
2) create Repository interfaces


Query creation Approaches
-----------------------------
1) Query creation by method name
2) Query creation using @Query
3) query creation using @NamedQuery

# Query creation by method name keywords:
	1) findBy
	2) getBy
	3) readBy
	4) queryBy	

	keyword+DataMember+<Operator>

@Entity
@Data
public class Passenger {
	@Id
	private Integer passengerId;
	private String firstName;
	private String lastName;
	private String email;
	private String contactNumber;
	private Integer seatNumber;
}

@Repository
public interface PassangerRepository extends JpaRepository<Passenger, Integer>{
	//JpaRepository<Entity_class_name, data_type_of_Id_field>

	Passenger findByEmail(String email);
	
	List<Passenger> findByFirstName(String firstName);

	List<Passenger> findByEmailOrContactNumber(String email, Long contactNumber);

	List<Passenger> findBySeatBetween(Integer seat1, Integer seat2);

	List<Passenger> findByLastNameOrderByFirstNameAsc(String lastName);

	List<Passenger> findBySeatNumberLt(Integer seatNumber);	

	List<Passenger> findBySeatNumberGreaterThanEqual(Integer seatNumber);

}
	
save()
saveAndFlush() // For both purposes- save or update
deleteById()
deleteAll()
existById()
findById()
findAll()


Can we use @OneToMany relation in Entity to fetch all data in Spring Boot Data JPA?
Can we create Join related query by method?

# Query creation using @Query
---------------------------------
JPQL(Java Persistence Query Language)/ SQL

select * from emp;// SQL QUERY
select e from Employee e; // JPQL QUERY - works on Entity classes

select empno, sal from emp;//SQL 
select e.empNumber, e.salary from Employee e;//JPQL

select * from emp where deptno=?//SQL
select e from Employee e where e.deptNumber=?1//JPQL [?1...?n where 1 to n is index parameter]

@Repository
public interface Employee extends JpaRepository<Employee, Integer>{
	
	//JPQL - with index parameters(?1)
	@Query("select e from Employee e where e.deptNumber=?1")
	List<Employee> getEmpsByDeptno(Integer deptno); //any method name can be used here

	//JPQL - with named parameters(:name) - more readable
	@Query("select e from Employee e where e.deptNumber=:deptno and e.empSal=:sal")
	List<Employee> getEmployees(Integer dno, double sal);
	or
	List<Employee> getEmployee(@Param("deptno") Integer dno, @Param("sal") Double sal);


	//JPQL
	@Query("select e.empNumber, e.empSal from Employee e") //Partial select query - returns List<Object[]>, array will contain empNum & sal
	List<Object[]> readEmployees();


	//SQL
	@Query(value="select * from emp where sal>?", nativeQuery=true)//need to pass second argument as "nativeQuery=true" in case of SQL query
	List<Employee> findEmpBySalary(double sal);
	
}

Query creation using @NamedQuery
------------------------------------
- Write/define Named Query in Entity class & add the same name in method in multiple repository to execute the query.
- JPQL query

@Entity
@NamedQuery(name="Employee.fetchEmpsByDeptno", query="select e from Employee e where e.deptNumber=?1")
//naming convention for name - Entity_class_name.method_name
@Table(name="emp")
public class Employee {
	---
	---
	---
}

@Repository
public interface EmployeeRepository extends JpaRepository<Employee, Integer>{
	List<Employee> fetchEmpsByDeptno(Integer dno);
}

Multiple named query - JPQL
------------------------------
@Entity
@NamedQueries({
	@NamedQuery(name="xxx", query="yyy"),
	@NamedQuery(name="xxxx", query="yyy")
})
@Table(name="emp")
public class Employee {
	---
	---
	---
}


Query creation using @NamedNativeQuery
----------------------------------------
- Write/define Named Native Query in Entity class & add the same name in method in multiple repository to execute the query.
- SQL query

@Entity
@NamedNativeQuery(name="Employee.fetchEmpsByDeptno", query="select * from emp where deptno=?1")
//naming convention for name - Entity_class_name.method_name
@Table(name="emp")
public class Employee {
	---
	---
	---
}

@Repository
public interface EmployeeRepository extends JpaRepository<Employee, Integer>{
	List<Employee> fetchEmpsByDeptno(Integer dno);
}

Multiple named native query - SQL Queries
--------------------------------------------
@Entity
@NamedNativeQueries({
	@NamedNativeQuery(name="nxxx", query="yyy"),
	@NamedNativeQuery(name="nxxxx", query="yyy")
})
@Table(name="emp")
public class Employee {
	---
	---
	---
}

e.g.
=========
STS -> starter project 

group: com.sathyatech
artifact : data.jpa1

dependencies : oracle driver, Spring Data JPA[spring-boot-starter-data-jpa], lombok

package com.jpa.entity
@Entity
@Data
//@NamedNativeQuery(name="Passenger.fetchPassangers", query="select * from passenger where first_name like '%k%' ")//SQL 
@NamedQuery(name="Passenger.fetchPassangers", query="select p from passenger where p.firstName like '%k%' ")//JPQL 
public class Passenger {
	@Id
	private Integer passengerId; //It will map with the column as "passanger_id"[capital letter in middle treats as _(underscore)] Or if it is different then use @Column(name="pid")
	
	@Column(length=15)//by default String mapping field in DB creates varchar2(255)
	private String firstName; //first_name

	@Column(length=15)
	private String lastName;

	@Column(length=25)
	private String email;

	private Long contactNumber;

	private Integer seatNo;
	
}

package com.jpa.repository
@Repository
public interface PassengerRepository extends JpaRepository<Passenger, Integer> {
	
	Passenger findByEmail(String email);
	
	@Query("select p from Passenger p where p.seatNo>=:from and p.seatNo<=:to")
	List<Passenger> readPassengerBetween(@Param("from") Integer from, @Param("to") Integer to);// @Param binds method parameter to named parameter of query
	
	List<Passenger> fetchPassangers();//from @NamedNativeQuery from Entity class
}

package com.jpa.runner
@Component
public class MyRunner extends CommandLineRunner {

	@Autowired
	PassengerRepository repo;

	@Override
	public void run(String... args) throws Exception {
		

		//Insert record
		Passenger p = new Passenger();
		p.setPassengerId(101);
		p.setFirstName("Ganesh");
		p.setLastName("Gupta");
		p.setEmail("ganesh@gmm.com");
		p.setContactNumber(111111111223L);
		p.setSeatNo(27);

		repo.save(p);

		

		//Find By Id
		//Optional object : Its like a container object - to avoid null pointer exception

		Optional<Passenger> opt = repo.findById(101);//return Optional
		Passenger p = opt.get();//
	
		System.out.println("Passenger Id = "+p.getPassengerId());
		System.out.println("Passenger Name = "+p.getFirstName()+" "+p.getLastName());

		
		//Find All
		List<Passenger> passengerList = repo.findAll();//Returns iterable object
		
		passengerList.forEach(p->{
			System.out.println("Passenger Id = "+p.getPassengerId());
			System.out.println("Passenger Name = "+p.getFirstName()+" "+p.getLastName());
			sysout("-----------");
		});

		//Custom JPA method query
		Passenger p = repo.findByEmail("meena@gmail.com");
			System.out.println("Passenger Id = "+p.getPassengerId());
			System.out.println("Passenger Name = "+p.getFirstName()+" "+p.getLastName());

		
		//Custom method by @NamedQuery
		List<Passenger> passengerList = repo. fetchPassangers();
		
		passengerList.forEach(p->{
			System.out.println("Passenger Id = "+p.getPassengerId());
			System.out.println("Passenger Name = "+p.getFirstName()+" "+p.getLastName());
			sysout("-----------");
		});	
		
	}

}

application.properties
------------------------
spring.datasource.driver-class-name=oracle.jdbc.driver.OracleDriver
spring.datasource.url=jdbc:oracle:thin:@localhost:1521:xe
spring.datasource.username=system
spring.datasource.password=y=tiger

spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=update ['create' = creates & drop - used for testing purpose | 'update' = does not drop, if table not exist in DB it creates]


run app


Sorting
--------------
Sort sort = Sort.by("firstName").ascending();//By default ascending
List<Passenger> passengerList = repo.findAll(sort);

Sort sort = Sort.by("firstName").ascending().and(Sort.by("seatNo").descending());
List<Passenger> passengerList = repo.findAll(sort);

Pagination
--------------
- get data by page wise - it requires Pageable interface & PageRequest class.

Pageable pageable = PageRequest.of(0,10,Sort.by("seatNo"));//first_page, number_of_records_per_page, sort_obj

Page<Passenger> page = repo.findAll(pageable);

page.getContent()
hasNext()
hasPrevious()
getNumber()
isFirst()
isLast()

MVC app for pagination
----------------------------
Jpa-Pagination

pom.xml - web, data-jpa, tomcat-embed-jasper, jstl, mysql-connector-java

package com.pagination.entity
@Entity
@Table(name="emp")
public class Employee {
	@Id
	private Integer empno;
	
	private String ename;
}

package com.pagination.repository
@Repository
public interface EmployeeRepository extends JpaRepository<Employee, Integer> {}

package com.pagination.service
public interface IEmployeeService {
	Page<Employee> findEmployees(int pageIndex);
}

package com.pagination.service.impl
public class EmployeeServiceImpl implements IEmployeeService {

	@Autowired
	EmployeeRepository repository;
	@Override
	public Page<Employee> findEmployees(int pageIndex) {
		Pageable pageable = PageRequest.of(pageIndex, 3, Sort.by("sal"));
		return repository.findAll(pageable);
	}

}

package com.pagination.controller
@Controller
public class EmployeeController {
	@Autowired 
	IEmployeeService service;

	@GetEmployee(value="/emps") //emps?pageIndex=1
	public String getEmployee(@RequestParam(defaultValue="0") int pageIndex, ModelMap modelMap) {

		//@RequestParam binds request parameters with method parameters
		//ModelMap object is accessible to the JSP page.

		Page<Employee> page = service.findEmployees(pageIndex);
		List<Employee> empList = page.getContent();
		modelMap.addAttribute("employees", empList);
		modelMap.addAttribute("next", page.hasNext()); //if(true) currentpage+1
		modelMap.addAttribute("back", page.hasPrevious()); //if(true) currentpage-1
		modelMap.addAttribute("currentPage", getNumber());
		
		return "ShowEmployee";

	}
}

src/main/webapp/WEB-INF/views/ShowEmployees.jsp
ShowEmployees.jsp

<%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>
<table>
	<header>
		<tr>
			<th>E. No</th>
			<th>E. Name</th>
			<th>Sal</th>
			<th>Dept No</th>
		</tr>
	</header>
	<c:if test="${!empty employees}">
		<c:forEach items="${employees}" var="e">
			<tr>		
			<td><c:out value="${e.empno}"/></td>
			<td><c:out value="${e.ename}"/></td>
			<td><c:out value="${e.sal}"/></td>
			<td><c:out value="${e.deptno}"/></td>
			</tr>
		</c:forEach>
	</c:if>
<table>

<c:if test="${back}">
	<a href="emps?pageIndex=${currentPage-1}">Back</a>
</c:if>

<c:if test="${next}">
	<a href="emps?pageIndex=${currentPage+1}">Next</a>
</c:if>

application.properties
-------------------------
server.servlet.context-path=/Pagination
spring.mvc.view.prefix=/WEB-INF/views/
spring.mvc.view.suffix=.jsp

spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/test
spring.datasource.username=root
spring.datasource.password=root

spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=update ['create' = creates & drop - used for testing purpose | 'update' = does not drop, if table not exist in DB it creates]

mysql> use db_name;
mysql> use test;
mysql> select * from emp; //empno|ename|sal|deptno


Relationships(Associations)
=================================
- To perform crud operations on multiple Entity classes at a time, we need association.

1) one-to-many
2) many-to-one
3) many-to-many
4) one-to-one

1) OneToMany
-----------------
Customer(1) -> Order(M)

Parent(1) -> Chile(M)

CUSTOMER [CUSTID(PK), CUSTNAME]
ORDERS [ORDERID(PK), ITEMNAME, ORDERDATE, CUSTID_FK(FK)]

Cascade=ALL ["Which operations to be cascaded" - "All means Save, Update, Delete" operations are cascaded on associated tables] 

@Entity
public class Customer {
	@Id
	private Integer custid;
	private String custname;
	
	@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER) //To be cascaded to the joined child table with all operations as save, update, delete

	@JoinColumn(name="custid_fk", referencedColumnName="custid") //takes [foreign key column - Foreign key exist in child table] and [referencedColumnName - primary key column in parent table] - referencedColumnName property is optional.
	private Set<Order> orders;
	
}

@Entity
@Table(name="ORDERS")
public class Order {
	@Id
	private Integer orderid;
	private LocalDate orderdate;
	private String itemname;
}


@OneToMany
@JoinColumn

Set<Order> orders = new HashSet<Order>();
orders.add(order1);
orders.add(order2);
orders.add(order3);

customer.setOrder(orders);

customerRepository.save(customer);

@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)//second parameter is optional
@JoinColumn(name="foriegn_key", referencedColumnName="primary_key_refered_by_foriegn_key")//second parameter is optional


e.g onetomay app 
------------------------


##Watch 2 days vidoes on desktop & update this notes.



ManyToOne relationship
---------------------------
spring starter project ->
name = manytoone
package = mto
dependencies = spring data JPA, lombok, oracle driver

*Lombok need to activate in IDE first time : 
1)Go to c:/users/admin/.m2/repository/org/projectlombok/lombok/1.18.12/lombok-1.18.12.jar
2)double click on lombok-1.18.12.jar
3)in the IDE selector window select your IDE, if IDE is not listed then click on specify location of installed IDE and select IDE.exe
4)click on install/update
5)quit it & restart IDE.

maven local repository = c:/users/admin/.m2/repository/

com.mto
com.mto.entity
com.mto.repository
com.mto.runner


com.mto.entity
@Entity
@Data //@Getter + @Setter + @RequiredArgsConstroctor + @ToString + @EqualsAndHashCode
@NoArgsConstructor
public class Customer {
	@Id
	private Integer custId;
	
	@Column(length=15)
	private String custName;
}

@Entity
@Data
@NoArgsConstructor
@Table(name="ORDERS")
public class Order {
	@Id
	private Integer id;

	private String itemName;

	private LocalDate orderDate;

	//Many Orders for One Customer - At the time of sav
	@ManyToOne(casecade=CasecadeType.ALL)//Here default fetch type is eager, not lazy. But in OneToMany default is lazy loading
	@JoinColumn(name="CUSTID_PK")//foriegn key column
	private Customer customer;//Reference variable to parent Entity class.
}

@Repository
public interface CustomerRepository extends JpaRepository<Customer, Integer> {}

@Repository
public interface OrderRepository extends JpaRepository<Order, Integer> {}

@Component
public class MyRunner implements CommandLineRunner throws Exception{
	@Autowired
	OrderRepository orderRepo;

	@Override
	public void run(String... args){

		Customer customer = new Customer();
		customer.setId(101);
		customer.setCustName("A");

		Order order1 = new Order();
		order1.setId(11101);
		order1.setItemName("Laptop");

		Order order2 = new Order();
		order2.setId(11102);
		order2.setItemName("Bag");


		//In Many to One, in 'many' Entity only need to set 'one' Entity
		order1.setCustomer(customer);
		order2.setCustomer(customer);

		orderRepo.save(order1);//first customer Entity will be inserted then order entity will be saved.
		orderRepo.save(order2);//Only the order entity will be inserted not customer at this time.

		//To check eager loading in Many to one
		//select order, it should fetch customer also.
		//If fetch type is set to lazy, then only order will be selected not customer.
		Order ord = orderRepo.findById(11101).get(); 

		//When an order is deleted, customer will also be deleted if one order is associated with the customer. If the customer is having another order associated then delete operation will throw Exception[integrity constraint violation - child record found]. To resolve this change the cascade type NOT to All
		orderRepo.deleteById(11101);

	}
}

application.properties
-------------------------

Many-To-Many
--------------
Category(1) - Item(M)
Item(1) - Category(M)

Book(1) - Author(M)
Author(1) - Books(M)

**ManyToMany relationship needs a join table with two foreign key columns.

Book(BookId, BookName, authorid_fk)
Author(AuthorId, AuthorName, bookid_fk)
BOOKS_AUTHORS(bookid_fk, authorid_fk) - Join Table

@JoinTable has to provide these three properties :
	1) name
	2) joinColumns
	3) inverseJoinColumns

	Only persist operation can be cascaded.


package com.mtm.Entity
@Entity
public class Book {
	@Id
	private Integer bookid;
	private String bookname;
	
	@ManyToMany(casecade=CasecadeType.ALL)
	@JoinTable(name="BOOKS_AUTHORS", joinColumns=@JoinColumn(name="BOOKID_FK"), inverseJoinColumns=@JoinColumn(name="AUTHORID_FK"))
	private Set<Author> authors;

}
package com.mtm.Entity
@Entity
public class Author {
	@Id
	private Integer authorid;
	private String authorname;

	@ManyToMany(cascade=CascadeType.ALL)
	@JoinTable(name="BOOKS_AUTHORS", joinColumns=@JoinColumn(name="AUTHORID_FK"), inverseJoinColumns=@JoinColumn(name="BOOK_FK"))
	private List<Book> books;
}

package com.mtm.repository
@Repository
public interface AuthorRepository extends JpaRepository<Autor, Integer> {}

@Repository
public interface BookRepository extends JpaRepository<Book, Integer> {}


package com.mtm.runner;
@Component
public class MyRunner implements CommandLineRunner {
	@Autowired
	BookRepository bookRepo;

	@Autowired
	AuthorRepository authorRepo;

	@Transactional // at method level or transaction level - 
	@Override
	public void run(String... args) throws Exception {
		/*

		Book b1 = new Book();
		b1.setBookId(1);
		b1.setBookName("Java");
		
		Author a1 = new Author();
		a1.setAuthorid(91);
		a1.setAuthorname("A");

		Author a2 = new Author();
		a2.setAuthorid(92);
		a2.setAuthorname("B");

		List<Author> authorsList = new ArrayList<>();
		authorsList.add(a1);
		authorsList.add(a2);

		b1.setAuthors(authorsList);

		Book b2 = new Book();
		b2.setBookId(2);
		b2.setBookName("Spring");

		Book b3 = new Book();
		b3.setBookId(3);
		b3.setBookName("Oracle");

		List<Book> booksList = new ArrayList<>();
		booksList.add(b2);
		booksList.add(b3);

		a2.setBooks(booksList);

		bookRepo.save(b1);

		*/

		/**
		* Add a new author to a book
		*
		*	1) Create a Author
		*	2) get book object from db
		*	3) get authorList from book object
		*	4) add newly created author to authorList
		* 	5) Use @Transactional or make a change in Entity to fetchType = EAGER.
		*/
		Author new_author = new Author();
		new_author.setAuthorid(93);
		new_author.setAuthorname("C");

		Book b = bookRepo.findById(1).get();
		List<Author> authList = b.getAuthors();
		authList.add(new_author);

		/**
		* Suppose need to remove an author from the specific book - use authList.remove(new_author);
		*
		*/
		

		//authorRepo.save(a2);//after inserting b1, uncomment this & comment above line & execute
		
	}
}

application.properties
----------------------------

SQL
----------------------------
select * from book;
select * from author;
select * from books_authors;

OneToOne
-----------------
person-passport
person-dl
desktop-employee

OneToOne relationship can be provided by two ways :
1) one to one with Foreign Key - id in the parent & child table will be different

	**Foreign key should not contain duplicate or null in child table

	PERSON (PERSONID, PERSONNAME)
	PASSPORT (PASSPORTID, EXPDATE, PERSONID_FK) // PERSONID_FK should not contain duplicate or null

2) one to one with Primary Key - id in the parent & child table will be same
	
	PERSON (PERSONID, PERSONNAME)
	PASSPORT (PASSPORTID, EXPDATE, PERSONID_FK)

@ManyToOne
@JoinColumn(name="fk", unique=true)

** Set parent entity reference to the child class.

e.g.
----------
@Entity
public class Person {
	@Id
	private Integer personid;

	private String personname;
}

@Entity
public class Passport { //Child class

	@Id
	private Integer passportNo;

	private LocalDate expDate;

	@ManyToOne(cascade=CascadeType.ALL)
	@JoiColumn(name="PERSONID_FK", unique=true) //One to one Foreign key
	private Person person;//parent reference in child
}

@Repository
public interface PassportRepository extends JpaRepository<Passport, Integer>{}
@Repository
public interface PersonRepository extends JpaRepository<Person, Integer>{}

package com.oto.runner;
@Component
public class MyRunner implements CommandLineRunner {
	
	@Autowired
	PassportRepository repo;

	@Override
	public void run(String... args) throws Exception {
		Person person = new Person();
		person.setPersonId(101);
		person.setPersonName("ANIL");

		/*Passport passport = new Passport();
		passport.setPassportNo(11231);
		passport.setExpDate(LocalDate.of(2025, 12, 31));
		passport.setPerson(person); //** Set parent entity reference to the child class.

		repo.save(passport);*/

		//To check one to one - create a new passport & assign the same peron - 101 - should throw unique constraint violation exception.
		Passport new_passport = new Passport();
		new_passport.setPassportNo(11233);
		new_passport.setExpDate(LocalDate.of(2024, 12, 31));
		new_passport.setPerson(person);

		repo.save(new_passport);
		
	}

}

By making a primary key as a foreign key in child entity, will make One to One relationship

OneToOne with primary key
--------------------------
- Without creating foreign key field in child table, it can be maintained OneToOne relationship.
 
@GenericGenerator - to define generator strategy for Id
@Id
@GeneratedValue - to assign GenericGenrator

STS - file - new project - "onetoonepk"
dependencies - Lombok, Oracle Driver, Spring Data Jpa

package com.oto.entity
@Entity
public class Person {
	@Id
	private Integer personId;

	private String personName;
}

@Entity
public class Passport { //Child class - make primary key as foreign key - copy id of the parent entity to child entity.

	@GenericGenerator(name = "g1", strategy = "foreign", parameters= @Parameter(name = "property", value = "person")) 
	//Foreign is a hibernate gennerator - to use this generator in generic manner use @GenericGenerator. "foreign" strategey copy id from parent property.
	//In @Parameter(name = "property", value = "person") //person is a parent property

	@Id
	@GeneratedValue(generator="g1")
	private Integer passportNo;

	private LocalDate expDate;

	@OneToOne(cascade=CascadeType.ALL)
	//In this case no JoinColumn required
	@PrimaryKeyJoinColumn //It tells that primary key is used as a foreign key
	private Person person;//parent reference in child
}

@Repository
public interface PassportRepository extends JpaRepository<Passport, Integer>{}
@Repository
public interface PersonRepository extends JpaRepository<Person, Integer>{}

package com.oto.runner;
@Component
public class MyRunner implements CommandLineRunner {
	
	@Autowired
	PassportRepository repo;

	@Override
	public void run(String... args) throws Exception {
		Person person = new Person();
		person.setPersonId(101);
		person.setPersonName("ANIL");

		Passport passport = new Passport();
		//passport.setPassportNo(11231); // Not required now - person_no will be copied to the passportNo - So it will be 101 as person_id
		passport.setExpDate(LocalDate.of(2025, 12, 31));
		passport.setPerson(person); //** Set parent entity reference to the child class.

		repo.save(passport); //passport & person will be saved but id of the both column would be same now.
 
		
	}

}

Joining - To read data from multiple entities
--------------------------------------------------
* To read the data from multiple tables in a single query - Join is used
For e.g. to fetch data from Customer & Order entities together at once.

A customer has many orders 
CUSTOMER(custid, custname, ...)
ORDER(orderid, itemname, orderdate, ...)

We can use JPQL(by using entity properties)/ SQL(by using table feilds) 

Inner Join (Default join) - fetch only matching data
Left Outer Join - more data from left
right Outer Join
full join


Inner Join - SQL
---------------------
select c.custname, o.itemname, o.orderdate from customer c join order o where c.custid=o.custid_fk;

Inner Join - JPQL
---------------------
select c.custname, o.itemname, o.orderdate from Customer c join c.orders o

//parent entity class having collection reference variable of child - here c.orders represents collection reference variable.

In ToMany
-------------
select c.customerName, o.itemName, o.orderDate from Customer c join c.orders o; //Inner Join


In ManyToOne
-------------
select c.customerName, o.itemName, o.orderDate from Order o join o.customer c; //Inner Join

In OneToMany project
------------------------
package com.otm.repository
@Repository
public interface CustomerRepository extends JpaRepository<Customer, Integer> {
	
	@Query("select c.custName, o.iteName, o.orderDate from Customer c inner join c.order o "); //JPQL | inner join fetches only matching data | it will return List<Object[]>
	List<Objetc[]> readData();

	or with left outer join
	@Query("select c.custName, o.iteName, o.orderDate from Customer c left outer join c.order o "); //JPQL | left Outer join fetches more data from left table.
	List<Objetc[]> readLeftOuterData();

	or with SQL join
	@Query(value = "", nativeQuery = true)
	List<Objetc[]> readSQLData();
	
}

public class MyRunner implements CommandLineRunner{

	@Autowired
	private CustomerRepository custRepo;

	public void run(String... args){
		List<Object[]> objList = custRepo.readData();
		objList.forEach(obj -> {
			System.out.println(obj[0]+" , "+obj[1]+" , "+obj[2]); //customerName, itemName, orderDate
		});
	}
}

1+N selects problem in Hibernate/ JPQL
=========================================
Suppose there are three customer on Customer table - for each customer multiple orders are there in Order table. 

select all the customers & read all of their orders.
1) one select statement will be executed to select all three customers.
2) then for each customers separate select statements will be executed to fetch their associated orders 
- So total number of select statement will be 1+3
- It decreases application performance

Solution for 1+N is @Fetch(FetchMode.SUBSELECT) with private Set<Order> orders in Customer Entity class;

select * from customer;
select * from orders;

for e.g. of 1+N issue in MyRunner.java of oneToMany app

	List<Customer> custList = custRepo.findAll();
	
	//It will fetch first list of all customers with 1 query
	//Then for all customers will fetch associated orders list by n queries.

@Fetch(FetchMode.SUBSELECT) // Two query will be executed(1+1 query)
@Fetch(FetchMode.JOIN) // Single query will be executed with join query of customer & order(1 query)
@Fetch(FetchMode.SELECT) // DEFAULT Fetch Mode - 1+N queries


In Customer Entity
@Entity
public class Customer {
	---
	---
	---
	@OneToMany(cascade=CasecadeType.All, fetch=FetchType.EAGER)
	@JoinColumn(name="CUSTID_FK")
	@Fetch(FetchMode.SUBSELECT) //FetchMode.JOIN uses single query with outer join select all the customer & their associated Orders
	private Set<Order> orders;

}


Bi-directional
-------------------
Entities : Customer, Order

In One to Many :
- Customer has associated orders with 1:M association

- When perform any operation on Customer like save/update/delete then, its associated collection will also be saved/updated/deleted(will be cascaded save/update/delete on associated orders)


In Many to One :
- Order Entity


If I want to perform operations on Customer should be performed same on Orders also, If I want to perform operations on Orders should be performed same on Customer also So, For this we need to provide both annotations - OneToMany & ManyToOne on both Entity classes. This situation combindly called OneToMany Bi-directional.


Customer {
	@OneToMany(mappedBy="customer") //mappedBy should be a field in target Entity, which makes this relation as bi-directional.
	//@OneToMany(casecade= CascadeType.ALL, fetch=FetchType.EAGER, mappedBy="customer")//Can be written like this.
	Set<Order> orders;
}

Order {
	@ManyToOne
	Customer customer;
}

If we use mappedBy then @JoinColumn can't be provided. @JoinColumn is provided on ManyToOne association.

@OneToMany(casecade= CascadeType.ALL, fetch=FetchType.EAGER, mappedBy="customer")


Procedure/ Function in Spring Data Jpa
===========================================





 





